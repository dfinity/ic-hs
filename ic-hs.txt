-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


@package ic-hs
@version 0.0.1

module IC.CBOR.Patterns
pattern TMap_ :: [(Term, Term)] -> Term
pattern TList_ :: [Term] -> Term
pattern TNat :: Natural -> Term
pattern TBlob :: ByteString -> Term

module IC.CBOR.Parser
decodeWithoutTag :: ByteString -> Either Text Term
decodeWithTag :: ByteString -> Either Text Term
parseMap :: Text -> Term -> Either Text [(Term, Term)]
parseBlob :: Text -> Term -> Either Text ByteString
parseField :: Text -> [(Term, a)] -> Either Text a
optionalField :: Text -> [(Term, a)] -> Either Text (Maybe a)


-- | This module provides a wrapper around primitive byte array, exposing
--   just the bits needed for accessing the stable memory.
module IC.Canister.StableMemory
type Memory s = STRef s Repr

-- | Immutable representation of stable memory that can be used for
--   snapshotting.
data Repr

-- | Constructs a new empty memory.
new :: HostM s (Memory s)

-- | Returns the size of stable memory in WebAssembly pages.
size :: Memory s -> HostM s Size

-- | Attempts to grow stable memory by <tt>delta</tt> pages.
grow :: Memory s -> Size -> HostM s Size

-- | Reads a range of bytes from memory.
read :: Memory s -> Address -> Size -> HostM s ByteString

-- | Writes a byte string at the specified offset.
write :: Memory s -> Address -> ByteString -> HostM s ()

-- | Exports immutable memory representation.
export :: Memory s -> ST s Repr

-- | Sets the contents of memory to a previously exported value.
imp :: Memory s -> Repr -> ST s ()

-- | Converts internal memory representation into a bytestring.
serialize :: Repr -> ByteString

-- | Constructs internal memory representation from a <tt>blob</tt>. Throws
--   an exception if the length of the <tt>blob</tt> is not a multiple of
--   64KiB.
deserialize :: ByteString -> Repr
instance GHC.Show.Show IC.Canister.StableMemory.Repr

module IC.Crypto.BLS
init :: IO ()
data SecretKey
createKey :: ByteString -> SecretKey
toPublicKey :: SecretKey -> ByteString
sign :: SecretKey -> ByteString -> ByteString
verify :: ByteString -> ByteString -> ByteString -> Bool
instance GHC.Generics.Generic IC.Crypto.BLS.SecretKey
instance GHC.Show.Show IC.Crypto.BLS.SecretKey
instance Foreign.Storable.Storable IC.Crypto.BLS.C'octet

module IC.Crypto.Bitcoin
newtype ExtendedSecretKey
ExtendedSecretKey :: XPrvKey -> ExtendedSecretKey
createExtendedKey :: ByteString -> ExtendedSecretKey
derivePrivateKey :: ExtendedSecretKey -> Vector ByteString -> Either String XPrvKey
derivePublicKey :: ExtendedSecretKey -> Vector ByteString -> Either String XPubKey
extractChainCode :: XPubKey -> ByteString
publicKeyToDER :: XPubKey -> ByteString
sign :: XPrvKey -> Hash256 -> ByteString
toHash256 :: ByteString -> Either String Hash256
toWord32 :: ByteString -> Either String Word32
instance GHC.Show.Show IC.Crypto.Bitcoin.ExtendedSecretKey

module IC.Crypto.DER.Decode
safeDecode :: ByteString -> Either String [ASN1]

module IC.Crypto.DER
data Suite
Ed25519 :: Suite
WebAuthn :: Suite
ECDSA :: Suite
Secp256k1 :: Suite
BLS :: Suite
CanisterSig :: Suite
encode :: Suite -> ByteString -> ByteString
decode :: ByteString -> Either Text (Suite, ByteString)
instance GHC.Show.Show IC.Crypto.DER.Suite

module IC.Crypto.DER_BLS
verify :: ByteString -> ByteString -> ByteString -> ByteString -> Either Text ()

module IC.Crypto.ECDSA
data SecretKey
createKey :: ByteString -> SecretKey
toPublicKey :: SecretKey -> ByteString
sign :: SecretKey -> ByteString -> IO ByteString
verify :: ByteString -> ByteString -> ByteString -> Bool
instance GHC.Show.Show IC.Crypto.ECDSA.SecretKey
instance GHC.Show.Show (Crypto.ECC.KeyPair Crypto.ECC.Curve_P256R1)

module IC.Crypto.Ed25519
type SecretKey = SecretKey
createKey :: ByteString -> SecretKey
toPublicKey :: SecretKey -> ByteString
sign :: SecretKey -> ByteString -> ByteString
verify :: ByteString -> ByteString -> ByteString -> Bool

module IC.Crypto.Secp256k1

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
init :: [a] -> [a]
data SecretKey
createKey :: ByteString -> SecretKey
toPublicKey :: SecretKey -> ByteString
sign :: SecretKey -> ByteString -> IO ByteString
verify :: ByteString -> ByteString -> ByteString -> Either Text ()
instance GHC.Show.Show IC.Crypto.Secp256k1.SecretKey

module IC.DRun.Parse
type MethodName = String
type Payload = ByteString
type Id = ByteString
data Ingress
Create :: Id -> Ingress
Install :: Id -> FilePath -> Payload -> Ingress
Reinstall :: Id -> FilePath -> Payload -> Ingress
Upgrade :: Id -> FilePath -> Payload -> Ingress
Update :: Id -> MethodName -> Payload -> Ingress
Query :: Id -> MethodName -> Payload -> Ingress
parseFile :: FilePath -> IO [Ingress]
parse :: String -> [Ingress]
parseLine :: String -> Ingress
parseId :: String -> Id
parseArg :: String -> Payload
instance GHC.Show.Show IC.DRun.Parse.Ingress


-- | This module describe a type for our “generic request (or response)”
--   format. It can be seen as a simplified (and more abstract) AST for
--   CBOR data.
--   
--   The following operations can be done on generic requests * Parsing
--   from CBOR * Encoding to CBOR * Request ID calculation * Thus: Signing
--   and signature checking
module IC.HTTP.GenR
data GenR
GBool :: Bool -> GenR
GNat :: Natural -> GenR
GText :: Text -> GenR
GBlob :: ByteString -> GenR
GRec :: HashMap Text GenR -> GenR
GList :: [GenR] -> GenR
emptyR :: GenR
(=:) :: Text -> v -> HashMap Text v
rec :: [HashMap Text GenR] -> GenR
instance GHC.Show.Show IC.HTTP.GenR.GenR


-- | Encoding from generic requests<i>responses to</i>from CBOR
module IC.HTTP.CBOR
encode :: GenR -> Builder
decode :: ByteString -> Either Text GenR


-- | Utilities to deconstruct a generic record.
module IC.HTTP.GenR.Parse
type RecordM m = StateT (HashMap Text GenR) m
type Field a = forall m. HasCallStack => Parse m => GenR -> m a
class Monad m => Parse m
parseError :: (Parse m, HasCallStack) => Text -> m a
record :: HasCallStack => Parse m => RecordM m a -> GenR -> m a
field :: HasCallStack => Parse m => Field a -> Text -> RecordM m a
optionalField :: HasCallStack => Parse m => Field a -> Text -> RecordM m (Maybe a)
swallowAllFields :: Monad m => RecordM m ()
anyType :: Field GenR
text :: Field Text
blob :: Field ByteString
nat :: Field Natural
percentage :: Field Natural
listOf :: Field a -> Field [a]
instance IC.HTTP.GenR.Parse.Parse (Data.Either.Either Data.Text.Internal.Text)
instance (GHC.Base.Monoid a, IC.HTTP.GenR.Parse.Parse m) => IC.HTTP.GenR.Parse.Parse (Control.Monad.Trans.Writer.Lazy.WriterT a m)
instance GHC.Base.Monad m => IC.HTTP.GenR.Parse.Parse (Control.Monad.Trans.Except.ExceptT Data.Text.Internal.Text m)

module IC.Hash
sha256 :: ByteString -> ByteString
sha224 :: ByteString -> ByteString


-- | This module implements the (possible pruned) merkle trees used in the
--   Internet Computer, in particular * Conversion from a labeled tree
--   (with blobs) * Root hash reconstruction * Lookup * Pruning * Checking
--   well-formedness
module IC.HashTree
type Blob = ByteString
type Path = [Label]
type Label = Blob
type Value = Blob
type Hash = Blob
data LabeledTree
Value :: Value -> LabeledTree
SubTrees :: Map Blob LabeledTree -> LabeledTree
data HashTree
EmptyTree :: HashTree
Fork :: HashTree -> HashTree -> HashTree
Labeled :: Blob -> HashTree -> HashTree
Leaf :: Value -> HashTree
Pruned :: Hash -> HashTree
construct :: LabeledTree -> HashTree
foldBinary :: a -> (a -> a -> a) -> [a] -> a
reconstruct :: HashTree -> Hash
h :: ByteString -> ByteString
domSep :: Blob -> Blob
data Res
Absent :: Res
Unknown :: Res
Error :: String -> Res
Found :: Value -> Res
lookupPath :: HashTree -> Path -> Res
flatten :: HashTree -> [HashTree]
prune :: HashTree -> [Path] -> HashTree
wellFormed :: HashTree -> Either String ()
wellFormedForest :: [HashTree] -> Either String ()
isInOrder :: [Label] -> Either String ()
instance GHC.Show.Show IC.HashTree.LabeledTree
instance GHC.Show.Show IC.HashTree.HashTree
instance GHC.Show.Show IC.HashTree.Res
instance GHC.Classes.Eq IC.HashTree.Res

module IC.Certificate
data Certificate
Certificate :: HashTree -> Blob -> Maybe Delegation -> Certificate
[cert_tree] :: Certificate -> HashTree
[cert_sig] :: Certificate -> Blob
[cert_delegation] :: Certificate -> Maybe Delegation
data Delegation
Delegation :: Blob -> Blob -> Delegation
[del_subnet_id] :: Delegation -> Blob
[del_certificate] :: Delegation -> Blob
instance GHC.Show.Show IC.Certificate.Delegation
instance GHC.Show.Show IC.Certificate.Certificate

module IC.HashTree.CBOR
encodeHashTree :: HashTree -> Term
parseHashTree :: Term -> Either Text HashTree

module IC.Certificate.CBOR
encodeCert :: Certificate -> Blob
decodeCert :: Blob -> Either Text Certificate


-- | Implements the special forms of ids
--   (https:/<i>sdk.dfinity.org</i>docs<i>interface-spec</i>index.html#id-classes)
module IC.Id.Forms
type Blob = ByteString
mkOpaqueId :: Blob -> Blob
isOpaqueId :: Blob -> Bool
mkSelfAuthenticatingId :: Blob -> Blob
isSelfAuthenticatingId :: Blob -> Blob -> Bool
mkDerivedId :: Blob -> Blob -> Blob
isDerivedId :: Blob -> Blob -> Bool
isAnonymousId :: Blob -> Bool
len_prefixed :: ByteString -> ByteString

module IC.Purify
class SnapshotAble i where {
    type SnapshotOf i :: Type;
}
persist :: SnapshotAble i => i s -> ST s (SnapshotOf i)
recreate :: SnapshotAble i => SnapshotOf i -> ST s (i s)
class Purify i a
create :: Purify i a => (forall s. ST s (i s)) -> a
createMaybe :: Purify i a => (forall s. ST s (b, Either c (i s))) -> (b, Either c a)
perform :: Purify i a => (forall s. i s -> ST s b) -> a -> (a, b)
newtype Snapshot a
Snapshot :: a -> Snapshot a
newtype Replay i
Replay :: (forall s. ST s (i s)) -> Replay i
instance GHC.Show.Show a => GHC.Show.Show (IC.Purify.Snapshot a)
instance GHC.Show.Show (IC.Purify.Replay i)
instance IC.Purify.Purify a (IC.Purify.Replay a)
instance (IC.Purify.SnapshotAble i, IC.Purify.SnapshotOf i GHC.Types.~ a) => IC.Purify.Purify i (IC.Purify.Snapshot a)


-- | This module provides an (optionally) persistent store for the state of
--   the IC.
--   
--   It provides: * atomic, blocking, exclusive write access * read access
--   to the latest state, at any time
--   
--   If not backed by a file, it is simply kept in memory.
--   
--   If backed by a file, state changes are serialized by a separate
--   thread. It waits for a state change to happen, then waits for 10s, and
--   then serializes the then youngest state. If the process is shut down
--   (via <a>conclude</a>), it serializes immediately.
--   
--   Serialization is atomic (write to a temporary file, then move), so it
--   _should_ be safe to kill the process; _a_ recent state will be
--   persisted.
module IC.StateFile
data Store a
withStore :: Serialise a => IO a -> Maybe FilePath -> (Store a -> IO b) -> IO b
modifyStore :: Serialise a => Store a -> StateT a IO b -> IO b
peekStore :: Store a -> IO a

module IC.Test.BLS
blsTests :: TestTree

module IC.Test.ECDSA
ecdsaTests :: TestTree

module IC.Test.HashTree
hashTreeTests :: TestTree
instance Test.QuickCheck.Arbitrary.Arbitrary IC.Test.HashTree.AsPaths
instance GHC.Show.Show IC.Test.HashTree.AsPaths
instance Test.QuickCheck.Arbitrary.Arbitrary IC.Test.HashTree.AsPath
instance GHC.Show.Show IC.Test.HashTree.AsPath
instance Test.QuickCheck.Arbitrary.Arbitrary IC.Test.HashTree.AsLabel
instance GHC.Show.Show IC.Test.HashTree.AsLabel
instance Test.QuickCheck.Arbitrary.Arbitrary IC.HashTree.LabeledTree

module IC.Test.Secp256k1
secp256k1Tests :: TestTree

module IC.Test.StableMemory
stableMemoryTests :: TestTree


-- | Helpers to program the “Universal module”. This is essentially a
--   small, type-safe DSL to produce the small stack-based programming
--   language interpreted by the universal canister.
--   
--   This DSL is expression-based, not stack based; seems to suite all our
--   needs and is simpler to work with.
--   
--   This language is not stable; therefore there is no separarte
--   documentation of specification than this file and
--   `universal-canister<i>src</i>`
module IC.Test.Universal
data T
I :: T
I64 :: T
B :: T
newtype Exp (result :: T)
[Exp] :: Builder -> Exp a
newtype Prog
[Prog] :: Builder -> Prog
run :: Prog -> ByteString
(>>>) :: Prog -> Prog -> Prog
class Op a
mkOp :: Op a => Word8 -> Builder -> a
op :: Op a => Word8 -> a
noop :: Prog
ignore :: Exp t -> Prog
int :: Word32 -> Exp 'I
bytes :: ByteString -> Exp 'B
replyDataAppend :: Exp 'B -> Prog
reply :: Prog
self :: Exp 'B
reject :: Exp 'B -> Prog
caller :: Exp 'B
reject_msg :: Exp 'B
reject_code :: Exp 'I
i2b :: Exp 'I -> Exp 'B
argData :: Exp 'B
cat :: Exp 'B -> Exp 'B -> Exp 'B
stableSize :: Exp 'I
stableGrow :: Exp 'I -> Exp 'I
stableRead :: Exp 'I -> Exp 'I -> Exp 'B
stableWrite :: Exp 'I -> Exp 'B -> Prog
debugPrint :: Exp 'B -> Prog
trap :: Exp 'B -> Prog
setGlobal :: Exp 'B -> Prog
getGlobal :: Exp 'B
badPrint :: Prog
onPreUpgrade :: Exp 'B -> Prog
getTime :: Exp 'I64
getAvailableCycles :: Exp 'I64
getBalance :: Exp 'I64
getRefund :: Exp 'I64
acceptCycles :: Exp 'I64 -> Exp 'I64
int64 :: Word64 -> Exp 'I64
callNew :: Exp 'B -> Exp 'B -> Exp 'B -> Exp 'B -> Prog
callDataAppend :: Exp 'B -> Prog
callCyclesAdd :: Exp 'I64 -> Prog
callPerform :: Prog
setCertifiedData :: Exp 'B -> Prog
getCertificatePresent :: Exp 'I
getCertificate :: Exp 'B
getStatus :: Exp 'I
onHeartbeat :: Exp 'B -> Prog
acceptMessage :: Prog
onInspectMessage :: Exp 'B -> Prog
trapIfEq :: Exp 'B -> Exp 'B -> Exp 'B -> Prog
callOnCleanup :: Exp 'B -> Prog
stableFill :: Exp 'I -> Exp 'I -> Exp 'I -> Prog
stable64Size :: Exp 'I64
stable64Grow :: Exp 'I64 -> Exp 'I64
stable64Read :: Exp 'I64 -> Exp 'I64 -> Exp 'B
stable64Write :: Exp 'I64 -> Exp 'B -> Prog
i64tob :: Exp 'I64 -> Exp 'B
getAvailableCycles128 :: Exp 'B
getBalance128 :: Exp 'B
getRefund128 :: Exp 'B
acceptCycles128 :: Exp 'I64 -> Exp 'I64 -> Exp 'B
callCyclesAdd128 :: Exp 'I64 -> Exp 'I64 -> Prog
onGlobalTimer :: Exp 'B -> Prog
apiGlobalTimerSet :: Exp 'I64 -> Exp 'I64
performanceCounter :: Exp 'I -> Exp 'I64
methodName :: Exp 'B
parsePrincipal :: Exp 'B -> Exp 'B
onTransform :: Exp 'B -> Prog
getHttpReplyWithBody :: Exp 'B -> Exp 'B
getHttpTransformContext :: Exp 'B -> Exp 'B
canisterVersion :: Exp 'I64
trapIfNeq :: Exp 'B -> Exp 'B -> Exp 'B -> Prog
mintCycles :: Exp 'I64 -> Exp 'I64
oneWayCallNew :: Exp 'B -> Exp 'B -> Prog
isController :: Exp 'B -> Exp 'I
callback :: Prog -> Exp 'B
replyData :: Exp 'B -> Prog
data OneWayCallArgs
OneWayCallArgs :: ByteString -> Word64 -> Word64 -> OneWayCallArgs
[ow_arg] :: OneWayCallArgs -> ByteString
[ow_cycles] :: OneWayCallArgs -> Word64
[ow_icpts] :: OneWayCallArgs -> Word64
oneway_call :: ByteString -> ByteString -> OneWayCallArgs -> Prog
data UpdateCallArgs
UpdateCallArgs :: Prog -> Prog -> Maybe Prog -> ByteString -> Word64 -> Word64 -> UpdateCallArgs
[uc_on_reply] :: UpdateCallArgs -> Prog
[uc_on_reject] :: UpdateCallArgs -> Prog
[uc_on_cleanup] :: UpdateCallArgs -> Maybe Prog
[uc_arg] :: UpdateCallArgs -> ByteString
[uc_cycles] :: UpdateCallArgs -> Word64
[uc_icpts] :: UpdateCallArgs -> Word64
update_call :: ByteString -> ByteString -> UpdateCallArgs -> Prog
data CallArgs
CallArgs :: Prog -> Prog -> Maybe Prog -> Prog -> Word64 -> Word64 -> CallArgs
[on_reply] :: CallArgs -> Prog
[on_reject] :: CallArgs -> Prog
[on_cleanup] :: CallArgs -> Maybe Prog
[other_side] :: CallArgs -> Prog
[cycles] :: CallArgs -> Word64
[icpts] :: CallArgs -> Word64
inter_call :: ByteString -> ByteString -> CallArgs -> Prog
inter_update :: ByteString -> CallArgs -> Prog
inter_query :: ByteString -> CallArgs -> Prog

-- | By default, the other side responds with some text indicating caller
--   and callee, and the callbacks reply with the response.
defOneWayArgs :: OneWayCallArgs
defUpdateArgs :: UpdateCallArgs
defArgs :: CallArgs
defaultOtherSide :: Prog
relayReplyImpl :: Prog
relayReply :: Prog
relayReplyRefund :: Word64 -> Prog
relayRejectImpl :: Prog
relayReject :: Prog
relayRejectRefund :: Word64 -> Prog
instance IC.Test.Universal.Op IC.Test.Universal.Prog
instance IC.Test.Universal.Op (IC.Test.Universal.Exp t)
instance IC.Test.Universal.Op a => IC.Test.Universal.Op (IC.Test.Universal.Exp t -> a)
instance GHC.Base.Semigroup IC.Test.Universal.Prog
instance GHC.Base.Monoid IC.Test.Universal.Prog
instance Data.String.IsString (IC.Test.Universal.Exp 'IC.Test.Universal.B)

module IC.Types
type (↦) = Map
type Blob = ByteString
type PublicKey = Blob
newtype EntityId
EntityId :: Blob -> EntityId
[rawEntityId] :: EntityId -> Blob
type CanisterId = EntityId
type CanisterRange = (CanisterId, CanisterId)
type SubnetId = EntityId
type UserId = EntityId
type MethodName = String
type RequestID = Blob
type Cycles = Natural
prettyBlob :: Blob -> String
prettyID :: EntityId -> String
parsePrettyID :: String -> Maybe EntityId
newtype NeedsToRespond
NeedsToRespond :: Bool -> NeedsToRespond
newtype Timestamp
Timestamp :: Natural -> Timestamp
data RejectCode
RC_SYS_FATAL :: RejectCode
RC_SYS_TRANSIENT :: RejectCode
RC_DESTINATION_INVALID :: RejectCode
RC_CANISTER_REJECT :: RejectCode
RC_CANISTER_ERROR :: RejectCode
rejectCode :: RejectCode -> Natural
data ErrorCode
EC_CANISTER_NOT_FOUND :: ErrorCode
EC_METHOD_NOT_FOUND :: ErrorCode
EC_CANISTER_EMPTY :: ErrorCode
EC_CANISTER_NOT_EMPTY :: ErrorCode
EC_CANISTER_STOPPED :: ErrorCode
EC_CANISTER_NOT_STOPPED :: ErrorCode
EC_CANISTER_NOT_RUNNING :: ErrorCode
EC_CANISTER_RESTARTED :: ErrorCode
EC_CANISTER_TRAPPED :: ErrorCode
EC_CANISTER_REJECTED :: ErrorCode
EC_CANISTER_DID_NOT_REPLY :: ErrorCode
EC_CANISTER_CONTRACT_VIOLATION :: ErrorCode
EC_INVALID_ENCODING :: ErrorCode
EC_INVALID_ARGUMENT :: ErrorCode
EC_INVALID_MODULE :: ErrorCode
EC_NOT_AUTHORIZED :: ErrorCode
errorCode :: ErrorCode -> String
data Response
Reply :: Blob -> Response
Reject :: (RejectCode, String) -> Response
data SubnetType
Application :: SubnetType
VerifiedApplication :: SubnetType
System :: SubnetType
peelOffPrefix :: [(a, String)] -> String -> Maybe (a, String)
data SubnetConfig
SubnetConfig :: SubnetType -> Word64 -> String -> [(Word64, Word64)] -> SubnetConfig
[subnet_type] :: SubnetConfig -> SubnetType
[subnet_size] :: SubnetConfig -> Word64
[nonce] :: SubnetConfig -> String
[canister_ranges] :: SubnetConfig -> [(Word64, Word64)]
type TestSubnetConfig = (EntityId, SubnetType, Word64, [(Word64, Word64)], [String])

-- | This data type contains all read-only data that should be available to
--   the canister almost always
data Status
Running :: Status
Stopping :: Status
Stopped :: Status
data Env
Env :: CanisterId -> Timestamp -> Cycles -> Status -> Maybe Blob -> Natural -> Natural -> Set EntityId -> Env
[env_self] :: Env -> CanisterId
[env_time] :: Env -> Timestamp
[env_balance] :: Env -> Cycles
[env_status] :: Env -> Status
[env_certificate] :: Env -> Maybe Blob
[env_canister_version] :: Env -> Natural
[env_global_timer] :: Env -> Natural
[env_controllers] :: Env -> Set EntityId
data TrapOr a
Trap :: String -> TrapOr a
Return :: a -> TrapOr a
data WasmClosure
WasmClosure :: Int32 -> Int32 -> WasmClosure
[closure_idx] :: WasmClosure -> Int32
[closure_env] :: WasmClosure -> Int32
data Callback
Callback :: WasmClosure -> WasmClosure -> Maybe WasmClosure -> Callback
[reply_callback] :: Callback -> WasmClosure
[reject_callback] :: Callback -> WasmClosure
[cleanup_callback] :: Callback -> Maybe WasmClosure
data MethodCall
MethodCall :: CanisterId -> MethodName -> Blob -> Callback -> Cycles -> MethodCall
[call_callee] :: MethodCall -> CanisterId
[call_method_name] :: MethodCall -> MethodName
[call_arg] :: MethodCall -> Blob
[call_callback] :: MethodCall -> Callback
[call_transferred_cycles] :: MethodCall -> Cycles
type ExistingCanisters = [CanisterId]
data ChangeOrigin
ChangeFromUser :: EntityId -> ChangeOrigin
[from_user_id] :: ChangeOrigin -> EntityId
ChangeFromCanister :: EntityId -> Maybe Word64 -> ChangeOrigin
[from_canister_id] :: ChangeOrigin -> EntityId
[from_canister_version] :: ChangeOrigin -> Maybe Word64
data CanisterInstallMode
Install :: CanisterInstallMode
Reinstall :: CanisterInstallMode
Upgrade :: CanisterInstallMode
data ChangeDetails
Creation :: [EntityId] -> ChangeDetails
[creation_controllers] :: ChangeDetails -> [EntityId]
CodeUninstall :: ChangeDetails
CodeDeployment :: CanisterInstallMode -> Blob -> ChangeDetails
[deployment_mode] :: ChangeDetails -> CanisterInstallMode
[deployment_module_hash] :: ChangeDetails -> Blob
ControllersChange :: [EntityId] -> ChangeDetails
[new_controllers] :: ChangeDetails -> [EntityId]
data Change
Change :: Word64 -> Word64 -> ChangeOrigin -> ChangeDetails -> Change
[timestamp_nanos] :: Change -> Word64
[new_canister_version] :: Change -> Word64
[change_origin] :: Change -> ChangeOrigin
[change_details] :: Change -> ChangeDetails
data CanisterActions
CanisterActions :: Maybe Blob -> Maybe Natural -> CanisterActions
[set_certified_data] :: CanisterActions -> Maybe Blob
[set_global_timer] :: CanisterActions -> Maybe Natural
noCanisterActions :: CanisterActions
data CallActions
CallActions :: [MethodCall] -> Cycles -> Cycles -> Maybe Response -> CallActions
[ca_new_calls] :: CallActions -> [MethodCall]
[ca_accept] :: CallActions -> Cycles
[ca_mint] :: CallActions -> Cycles
[ca_response] :: CallActions -> Maybe Response
noCallActions :: CallActions
type UpdateResult = (CallActions, CanisterActions)
type StableMemory = Blob
type ValidityPred a = forall m. MonadError Text m => a -> m ()
data EnvValidity
EnvValidity :: ValidityPred Timestamp -> ValidityPred EntityId -> ValidityPred EntityId -> EnvValidity
[valid_when] :: EnvValidity -> ValidityPred Timestamp
[valid_for] :: EnvValidity -> ValidityPred EntityId
[valid_where] :: EnvValidity -> ValidityPred EntityId
validWhen :: ValidityPred Timestamp -> EnvValidity
validFor :: ValidityPred EntityId -> EnvValidity
validWhere :: ValidityPred EntityId -> EnvValidity
instance GHC.Classes.Ord IC.Types.EntityId
instance GHC.Classes.Eq IC.Types.EntityId
instance GHC.Show.Show IC.Types.EntityId
instance GHC.Classes.Eq IC.Types.NeedsToRespond
instance GHC.Show.Show IC.Types.NeedsToRespond
instance GHC.Classes.Eq IC.Types.Timestamp
instance GHC.Classes.Ord IC.Types.Timestamp
instance GHC.Num.Num IC.Types.Timestamp
instance GHC.Show.Show IC.Types.Timestamp
instance GHC.Show.Show IC.Types.RejectCode
instance GHC.Enum.Enum IC.Types.ErrorCode
instance GHC.Show.Show IC.Types.ErrorCode
instance GHC.Show.Show IC.Types.Response
instance GHC.Classes.Eq IC.Types.SubnetType
instance GHC.Base.Functor IC.Types.TrapOr
instance GHC.Show.Show IC.Types.WasmClosure
instance GHC.Classes.Eq IC.Types.WasmClosure
instance GHC.Show.Show IC.Types.Callback
instance GHC.Classes.Eq IC.Types.Callback
instance GHC.Show.Show IC.Types.MethodCall
instance GHC.Show.Show IC.Types.ChangeOrigin
instance GHC.Show.Show IC.Types.CanisterInstallMode
instance GHC.Show.Show IC.Types.ChangeDetails
instance GHC.Show.Show IC.Types.Change
instance GHC.Base.Semigroup IC.Types.EnvValidity
instance GHC.Base.Monoid IC.Types.EnvValidity
instance GHC.Base.Semigroup IC.Types.CanisterActions
instance GHC.Read.Read IC.Types.SubnetType
instance GHC.Show.Show IC.Types.SubnetType
instance GHC.Read.Read IC.Types.EntityId

module IC.Management
principalToEntityId :: Principal -> EntityId
entityIdToPrincipal :: EntityId -> Principal
type SenderCanisterVersion = (Rec ((.+) ((.==) "sender_canister_version" (Maybe Word64)) Empty))
type InstallMode = (Var ((.+) ((.==) "install" ()) ((.+) ((.==) "reinstall" ()) ((.+) ((.==) "upgrade" ()) Empty))))
type RunState = (Var ((.+) ((.==) "running" ()) ((.+) ((.==) "stopping" ()) ((.+) ((.==) "stopped" ()) Empty))))
type Settings = (Rec ((.+) ((.==) "controllers" (Maybe (Vector Principal))) ((.+) ((.==) "compute_allocation" (Maybe Natural)) ((.+) ((.==) "memory_allocation" (Maybe Natural)) ((.+) ((.==) "freezing_threshold" (Maybe Natural)) Empty)))))
type HttpHeader = (Rec ((.+) ((.==) "name" Text) ((.+) ((.==) "value" Text) Empty)))
type HttpResponse = (Rec ((.+) ((.==) "status" Natural) ((.+) ((.==) "headers" (Vector (Rec ((.+) ((.==) "name" Text) ((.+) ((.==) "value" Text) Empty))))) ((.+) ((.==) "body" ByteString) Empty))))
type CandidChangeOrigin = (Var ((.+) ((.==) "from_user" (Rec ((.+) ((.==) "user_id" Principal) Empty))) ((.+) ((.==) "from_canister" (Rec ((.+) ((.==) "canister_id" Principal) ((.+) ((.==) "canister_version" (Maybe Word64)) Empty)))) Empty)))
mapChangeOrigin :: ChangeOrigin -> CandidChangeOrigin
type CandidChangeDetails = (Var ((.+) ((.==) "creation" (Rec ((.+) ((.==) "controllers" (Vector Principal)) Empty))) ((.+) ((.==) "code_uninstall" ()) ((.+) ((.==) "code_deployment" (Rec ((.+) ((.==) "mode" (Var ((.+) ((.==) "install" ()) ((.+) ((.==) "reinstall" ()) ((.+) ((.==) "upgrade" ()) Empty))))) ((.+) ((.==) "module_hash" ByteString) Empty)))) ((.+) ((.==) "controllers_change" (Rec ((.+) ((.==) "controllers" (Vector Principal)) Empty))) Empty)))))
mapChangeDetails :: ChangeDetails -> CandidChangeDetails
type ICManagement m = ((.+) ((.+) ((.+) ((.+) ((.+) ((.+) ((.+) ((.+) ((.+) ((.+) ((.+) ((.+) ((.+) ((.+) ((.+) ((.==) "create_canister" (Rec ((.+) ((.==) "settings" (Maybe (Rec ((.+) ((.==) "controllers" (Maybe (Vector Principal))) ((.+) ((.==) "compute_allocation" (Maybe Natural)) ((.+) ((.==) "memory_allocation" (Maybe Natural)) ((.+) ((.==) "freezing_threshold" (Maybe Natural)) Empty))))))) ((.+) ((.==) "sender_canister_version" (Maybe Word64)) Empty)) -> m_aGO2 (Rec ((.+) ((.==) "canister_id" Principal) Empty)))) ((.==) "update_settings" (Rec ((.+) ((.==) "canister_id" Principal) ((.+) ((.==) "settings" (Rec ((.+) ((.==) "controllers" (Maybe (Vector Principal))) ((.+) ((.==) "compute_allocation" (Maybe Natural)) ((.+) ((.==) "memory_allocation" (Maybe Natural)) ((.+) ((.==) "freezing_threshold" (Maybe Natural)) Empty)))))) ((.+) ((.==) "sender_canister_version" (Maybe Word64)) Empty))) -> m_aGO2 ()))) ((.==) "install_code" (Rec ((.+) ((.==) "mode" (Var ((.+) ((.==) "install" ()) ((.+) ((.==) "reinstall" ()) ((.+) ((.==) "upgrade" ()) Empty))))) ((.+) ((.==) "canister_id" Principal) ((.+) ((.==) "wasm_module" ByteString) ((.+) ((.==) "arg" ByteString) ((.+) ((.==) "sender_canister_version" (Maybe Word64)) Empty))))) -> m_aGO2 ()))) ((.==) "uninstall_code" (Rec ((.+) ((.==) "canister_id" Principal) ((.+) ((.==) "sender_canister_version" (Maybe Word64)) Empty)) -> m_aGO2 ()))) ((.==) "start_canister" (Rec ((.+) ((.==) "canister_id" Principal) Empty) -> m_aGO2 ()))) ((.==) "stop_canister" (Rec ((.+) ((.==) "canister_id" Principal) Empty) -> m_aGO2 ()))) ((.==) "canister_status" (Rec ((.+) ((.==) "canister_id" Principal) Empty) -> m_aGO2 (Rec ((.+) ((.==) "status" (Var ((.+) ((.==) "running" ()) ((.+) ((.==) "stopping" ()) ((.+) ((.==) "stopped" ()) Empty))))) ((.+) ((.==) "settings" (Rec ((.+) ((.==) "controllers" (Vector Principal)) ((.+) ((.==) "compute_allocation" Natural) ((.+) ((.==) "memory_allocation" Natural) ((.+) ((.==) "freezing_threshold" Natural) Empty)))))) ((.+) ((.==) "module_hash" (Maybe ByteString)) ((.+) ((.==) "memory_size" Natural) ((.+) ((.==) "cycles" Natural) ((.+) ((.==) "idle_cycles_burned_per_day" Natural) Empty)))))))))) ((.==) "canister_info" (Rec ((.+) ((.==) "canister_id" Principal) ((.+) ((.==) "num_requested_changes" (Maybe Word64)) Empty)) -> m_aGO2 (Rec ((.+) ((.==) "total_num_changes" Word64) ((.+) ((.==) "recent_changes" (Vector (Rec ((.+) ((.==) "timestamp_nanos" Word64) ((.+) ((.==) "canister_version" Word64) ((.+) ((.==) "origin" (Var ((.+) ((.==) "from_user" (Rec ((.+) ((.==) "user_id" Principal) Empty))) ((.+) ((.==) "from_canister" (Rec ((.+) ((.==) "canister_id" Principal) ((.+) ((.==) "canister_version" (Maybe Word64)) Empty)))) Empty)))) ((.+) ((.==) "details" (Var ((.+) ((.==) "creation" (Rec ((.+) ((.==) "controllers" (Vector Principal)) Empty))) ((.+) ((.==) "code_uninstall" ()) ((.+) ((.==) "code_deployment" (Rec ((.+) ((.==) "mode" (Var ((.+) ((.==) "install" ()) ((.+) ((.==) "reinstall" ()) ((.+) ((.==) "upgrade" ()) Empty))))) ((.+) ((.==) "module_hash" ByteString) Empty)))) ((.+) ((.==) "controllers_change" (Rec ((.+) ((.==) "controllers" (Vector Principal)) Empty))) Empty)))))) Empty))))))) ((.+) ((.==) "module_hash" (Maybe ByteString)) ((.+) ((.==) "controllers" (Vector Principal)) Empty)))))))) ((.==) "delete_canister" (Rec ((.+) ((.==) "canister_id" Principal) Empty) -> m_aGO2 ()))) ((.==) "deposit_cycles" (Rec ((.+) ((.==) "canister_id" Principal) Empty) -> m_aGO2 ()))) ((.==) "raw_rand" (() -> m_aGO2 ByteString))) ((.==) "http_request" (Rec ((.+) ((.==) "url" Text) ((.+) ((.==) "max_response_bytes" (Maybe Word64)) ((.+) ((.==) "method" (Var ((.+) ((.==) "get" ()) ((.+) ((.==) "head" ()) ((.+) ((.==) "post" ()) Empty))))) ((.+) ((.==) "headers" (Vector (Rec ((.+) ((.==) "name" Text) ((.+) ((.==) "value" Text) Empty))))) ((.+) ((.==) "body" (Maybe ByteString)) ((.+) ((.==) "transform" (Maybe (Rec ((.+) ((.==) "function" (FuncRef (Rec ((.+) ((.==) "response" (Rec ((.+) ((.==) "status" Natural) ((.+) ((.==) "headers" (Vector (Rec ((.+) ((.==) "name" Text) ((.+) ((.==) "value" Text) Empty))))) ((.+) ((.==) "body" ByteString) Empty))))) ((.+) ((.==) "context" ByteString) Empty)), Rec ((.+) ((.==) "status" Natural) ((.+) ((.==) "headers" (Vector (Rec ((.+) ((.==) "name" Text) ((.+) ((.==) "value" Text) Empty))))) ((.+) ((.==) "body" ByteString) Empty))), AnnTrue, AnnFalse))) ((.+) ((.==) "context" ByteString) Empty))))) Empty)))))) -> m_aGO2 (Rec ((.+) ((.==) "status" Natural) ((.+) ((.==) "headers" (Vector (Rec ((.+) ((.==) "name" Text) ((.+) ((.==) "value" Text) Empty))))) ((.+) ((.==) "body" ByteString) Empty))))))) ((.==) "ecdsa_public_key" (Rec ((.+) ((.==) "canister_id" (Maybe Principal)) ((.+) ((.==) "derivation_path" (Vector ByteString)) ((.+) ((.==) "key_id" (Rec ((.+) ((.==) "curve" (Var ((.+) ((.==) "secp256k1" ()) Empty))) ((.+) ((.==) "name" Text) Empty)))) Empty))) -> m_aGO2 (Rec ((.+) ((.==) "public_key" ByteString) ((.+) ((.==) "chain_code" ByteString) Empty)))))) ((.==) "sign_with_ecdsa" (Rec ((.+) ((.==) "message_hash" ByteString) ((.+) ((.==) "derivation_path" (Vector ByteString)) ((.+) ((.==) "key_id" (Rec ((.+) ((.==) "curve" (Var ((.+) ((.==) "secp256k1" ()) Empty))) ((.+) ((.==) "name" Text) Empty)))) Empty))) -> m_aGO2 (Rec ((.+) ((.==) "signature" ByteString) Empty))))) ((.==) "provisional_create_canister_with_cycles" (Rec ((.+) ((.==) "amount" (Maybe Natural)) ((.+) ((.==) "settings" (Maybe (Rec ((.+) ((.==) "controllers" (Maybe (Vector Principal))) ((.+) ((.==) "compute_allocation" (Maybe Natural)) ((.+) ((.==) "memory_allocation" (Maybe Natural)) ((.+) ((.==) "freezing_threshold" (Maybe Natural)) Empty))))))) ((.+) ((.==) "specified_id" (Maybe Principal)) ((.+) ((.==) "sender_canister_version" (Maybe Word64)) Empty)))) -> m_aGO2 (Rec ((.+) ((.==) "canister_id" Principal) Empty))))) ((.==) "provisional_top_up_canister" (Rec ((.+) ((.==) "canister_id" Principal) ((.+) ((.==) "amount" Natural) Empty)) -> m_aGO2 ())))
managementMethods :: [String]

module IC.Ref.IO
sendHttpRequest :: [SignedCertificate] -> Text -> ByteString -> [(CI ByteString, ByteString)] -> ByteString -> IO (Either String HttpResponse)

module IC.Id.Fresh
freshId :: [(Word64, Word64)] -> [EntityId] -> Maybe EntityId
wordToId' :: Word64 -> Blob
wordToId :: Word64 -> EntityId
checkCanisterIdInRanges' :: [(Blob, Blob)] -> Blob -> Bool
checkCanisterIdInRanges :: [(Word64, Word64)] -> CanisterId -> Bool
isRootTestSubnet :: TestSubnetConfig -> Bool

module IC.Constants
cDEFAULT_PROVISIONAL_CYCLES_BALANCE :: Natural
canister_ids_per_subnet :: Word64
nth_canister_range :: Word64 -> (Word64, Word64)
reference_subnet_size :: Word64
max_request_bytes_limit :: Word64
max_response_bytes_limit :: Word64
max_http_request_url_length :: Word64
http_headers_max_number :: Int
http_headers_max_name_value_length :: Word64
http_headers_max_total_size :: Word64
getHttpRequestBaseFee :: SubnetType -> Word64
getHttpRequestPerSubnetSizeFee :: SubnetType -> Word64
getHttpRequestPerRequestByteFee :: SubnetType -> Word64
getHttpRequestPerResponseByteFee :: SubnetType -> Word64

module IC.Certificate.Validate
validateCertificate :: Blob -> Certificate -> Either Text ()

module IC.Crypto.CanisterSig

-- | Produces a public key, without the DER wrapping
genPublicKey :: EntityId -> ByteString -> ByteString
genSig :: Certificate -> HashTree -> ByteString
verify :: ByteString -> ByteString -> ByteString -> ByteString -> Either Text ()

module IC.CBOR.Utils
encodePrincipalList :: [EntityId] -> Blob
encodeCanisterRangeList :: [CanisterRange] -> Blob


-- | Generic utilities related to standard or imported data structures that
--   we do don’t want to see in non-plumbing code.
module IC.Utils
freshKey :: Map Int a -> Int
repeatWhileTrue :: Monad m => m Bool -> m ()
duplicates :: Ord a => [a] -> [a]
toUtf8 :: Text -> ByteString
fromUtf8 :: ByteString -> Maybe Text
utf8_length :: Text -> Word64
data RefConfig
RefConfig :: [SignedCertificate] -> RefConfig
[tc_root_certs] :: RefConfig -> [SignedCertificate]
makeRefConfig :: [SignedCertificate] -> IO RefConfig
type HasRefConfig = (?refConfig :: RefConfig)
withRefConfig :: RefConfig -> (HasRefConfig => a) -> a
refConfig :: HasRefConfig => RefConfig
getRootCerts :: HasRefConfig => [SignedCertificate]
max_response_size :: (r .! "max_response_bytes") ~ Maybe Word64 => Rec r -> Word64
http_request_fee :: (a -> IO b) ~ (ICManagement IO .! "http_request") => a -> (SubnetType, Word64) -> Word64
http_request_headers_total_size :: (a -> IO b) ~ (ICManagement IO .! "http_request") => Integral c => a -> c
check_http_request_headers_number :: (a -> IO b) ~ (ICManagement IO .! "http_request") => a -> Bool
check_http_request_headers_name_length :: (a -> IO b) ~ (ICManagement IO .! "http_request") => a -> Bool
check_http_request_headers_value_length :: (a -> IO b) ~ (ICManagement IO .! "http_request") => a -> Bool
check_http_request_headers_total_size :: (a -> IO b) ~ (ICManagement IO .! "http_request") => a -> Bool
http_request_size :: (a -> IO b) ~ (ICManagement IO .! "http_request") => Integral c => a -> c
http_response_headers :: (a -> IO b) ~ (ICManagement IO .! "http_request") => b -> [(Text, Text)]
http_response_headers_total_size :: (a -> IO b) ~ (ICManagement IO .! "http_request") => Integral c => b -> c
check_http_response_headers_number :: (a -> IO b) ~ (ICManagement IO .! "http_request") => b -> Bool
check_http_response_headers_name_length :: (a -> IO b) ~ (ICManagement IO .! "http_request") => b -> Bool
check_http_response_headers_value_length :: (a -> IO b) ~ (ICManagement IO .! "http_request") => b -> Bool
check_http_response_headers_total_size :: (a -> IO b) ~ (ICManagement IO .! "http_request") => b -> Bool
http_response_size :: (a -> IO b) ~ (ICManagement IO .! "http_request") => b -> Word64

module IC.HTTP.RequestId
requestId :: GenR -> RequestId


-- | This module implements WebAuthN crypto. WebauthN is a big mess,
--   involving nesting of CBOR, DER and JSON…
module IC.Crypto.WebAuthn

-- | &lt;math&gt;. Return all the elements of a list except the last one.
--   The list must be non-empty.
--   
--   <pre>
--   &gt;&gt;&gt; init [1, 2, 3]
--   [1,2]
--   
--   &gt;&gt;&gt; init [1]
--   []
--   
--   &gt;&gt;&gt; init []
--   *** Exception: Prelude.init: empty list
--   </pre>
init :: [a] -> [a]
data SecretKey
createECDSAKey :: ByteString -> SecretKey
createRSAKey :: ByteString -> SecretKey
toPublicKey :: SecretKey -> ByteString
sign :: SecretKey -> ByteString -> IO ByteString
verify :: ByteString -> ByteString -> ByteString -> Either Text ()
instance GHC.Show.Show IC.Crypto.WebAuthn.SecretKey

module IC.Test.WebAuthn
webAuthnTests :: TestTree


-- | Everything related to signature creation and checking
module IC.Crypto
data SecretKey
Ed25519 :: SecretKey -> SecretKey
ECDSA :: SecretKey -> SecretKey
Secp256k1 :: SecretKey -> SecretKey
WebAuthn :: SecretKey -> SecretKey
BLS :: SecretKey -> SecretKey
createSecretKeyEd25519 :: ByteString -> SecretKey
createSecretKeyWebAuthnECDSA :: ByteString -> SecretKey
createSecretKeyWebAuthnRSA :: ByteString -> SecretKey
createSecretKeyECDSA :: ByteString -> SecretKey
createSecretKeySecp256k1 :: ByteString -> SecretKey
createSecretKeyBLS :: ByteString -> SecretKey
toPublicKey :: SecretKey -> ByteString
signPure :: ByteString -> SecretKey -> ByteString -> ByteString
sign :: ByteString -> SecretKey -> ByteString -> IO ByteString
verify :: ByteString -> ByteString -> ByteString -> ByteString -> ByteString -> Either Text ()
instance GHC.Show.Show IC.Crypto.SecretKey

module IC.Test.Options
newtype Endpoint
Endpoint :: String -> Endpoint
endpointOption :: OptionDescription
newtype Httpbin
Httpbin :: String -> Httpbin
httpbinOption :: OptionDescription
newtype PollTimeout
PollTimeout :: Int -> PollTimeout
polltimeoutOption :: OptionDescription
newtype AllowSelfSignedCerts
AllowSelfSignedCerts :: Bool -> AllowSelfSignedCerts
allowSelfSignedCertsOption :: OptionDescription
getSubnetIdFromNonce :: String -> EntityId
defaultSysTestSubnetConfig :: TestSubnetConfig
defaultAppTestSubnetConfig :: TestSubnetConfig
readTestSubnetConfig :: Int -> ReadS TestSubnetConfig
newtype TestSubnet
TestSubnet :: TestSubnetConfig -> TestSubnet
testSubnetOption :: OptionDescription
newtype PeerSubnet
PeerSubnet :: TestSubnetConfig -> PeerSubnet
peerSubnetOption :: OptionDescription
instance GHC.Read.Read IC.Test.Options.PeerSubnet
instance GHC.Show.Show IC.Test.Options.PeerSubnet
instance Test.Tasty.Options.IsOption IC.Test.Options.PeerSubnet
instance GHC.Read.Read IC.Test.Options.TestSubnet
instance GHC.Show.Show IC.Test.Options.TestSubnet
instance Test.Tasty.Options.IsOption IC.Test.Options.TestSubnet
instance Test.Tasty.Options.IsOption IC.Test.Options.AllowSelfSignedCerts
instance Test.Tasty.Options.IsOption IC.Test.Options.PollTimeout
instance Test.Tasty.Options.IsOption IC.Test.Options.Httpbin
instance Test.Tasty.Options.IsOption IC.Test.Options.Endpoint

module IC.Certificate.Value
class CertVal a
toCertVal :: CertVal a => a -> Blob
fromCertVal :: CertVal a => Blob -> Maybe a
instance IC.Certificate.Value.CertVal IC.Types.Blob
instance IC.Certificate.Value.CertVal Data.Text.Internal.Text
instance IC.Certificate.Value.CertVal GHC.Num.Natural.Natural


-- | This module provides a thin wrapper around the winter Wasm engine,
--   exposing just the bits needed by the IC ref.
--   
--   This is the interface at which one might plug in a different Wasm
--   engine.
module IC.Wasm.Winter
type Module = Module Phrase
parseModule :: ByteString -> Either String Module
exportedFunctions :: Module -> [FuncName]
type Import s = (ModName, FuncName, StackType, StackType, [Value] -> HostFunc s)
type Imports s = [Import s]
type HostM s = ExceptT String (ST s)
type HostFunc s = HostM s [Value]
data Value
I32 :: {-# UNPACK #-} !Int32 -> Value
I64 :: {-# UNPACK #-} !Int64 -> Value
F32 :: {-# UNPACK #-} !Float -> Value
F64 :: {-# UNPACK #-} !Double -> Value
type StackType = [ValueType]
data ValueType
I32Type :: ValueType
I64Type :: ValueType
F32Type :: ValueType
F64Type :: ValueType
type Address = Int64
type Size = Int32
getBytes :: Instance s -> Address -> Size -> HostM s ByteString
setBytes :: Instance s -> Address -> ByteString -> HostM s ()
initialize :: forall s. Module -> Imports s -> HostM s (Instance s)
type Instance s = (IntMap (ModuleInst Phrase (ST s)), Int)
invokeExport :: Instance s -> FuncName -> [Value] -> HostM s [Value]
invokeTable :: Instance s -> Int32 -> [Value] -> HostM s [Value]

module IC.Wasm.Imports
class WasmArg a
valueType :: WasmArg a => ValueType
fromValue :: WasmArg a => Value -> Either String a
toValue :: WasmArg a => a -> Value
class WasmArgs a
stackType :: WasmArgs a => StackType
fromValues :: WasmArgs a => [Value] -> Either String a
toValues :: WasmArgs a => a -> [Value]
stackType :: (WasmArgs a, WasmArg a) => StackType
fromValues :: (WasmArgs a, WasmArg a) => [Value] -> Either String a
toValues :: (WasmArgs a, WasmArg a) => a -> [Value]
argError :: Int -> [a] -> Either String b
toImport :: forall a b s. (WasmArgs a, WasmArgs b) => String -> String -> (a -> HostM s b) -> Import s
instance IC.Wasm.Imports.WasmArgs GHC.Int.Int32
instance IC.Wasm.Imports.WasmArgs GHC.Word.Word64
instance IC.Wasm.Imports.WasmArgs ()
instance (IC.Wasm.Imports.WasmArg a1, IC.Wasm.Imports.WasmArg a2) => IC.Wasm.Imports.WasmArgs (a1, a2)
instance (IC.Wasm.Imports.WasmArg a1, IC.Wasm.Imports.WasmArg a2, IC.Wasm.Imports.WasmArg a3, IC.Wasm.Imports.WasmArg a4) => IC.Wasm.Imports.WasmArgs (a1, a2, a3, a4)
instance (IC.Wasm.Imports.WasmArg a1, IC.Wasm.Imports.WasmArg a2, IC.Wasm.Imports.WasmArg a3) => IC.Wasm.Imports.WasmArgs (a1, a2, a3)
instance (IC.Wasm.Imports.WasmArg a1, IC.Wasm.Imports.WasmArg a2, IC.Wasm.Imports.WasmArg a3, IC.Wasm.Imports.WasmArg a4, IC.Wasm.Imports.WasmArg a5, IC.Wasm.Imports.WasmArg a6, IC.Wasm.Imports.WasmArg a7, IC.Wasm.Imports.WasmArg a8) => IC.Wasm.Imports.WasmArgs (a1, a2, a3, a4, a5, a6, a7, a8)
instance (IC.Wasm.Imports.WasmArg a1, IC.Wasm.Imports.WasmArg a2, IC.Wasm.Imports.WasmArg a3, IC.Wasm.Imports.WasmArg a4, IC.Wasm.Imports.WasmArg a5, IC.Wasm.Imports.WasmArg a6, IC.Wasm.Imports.WasmArg a7, IC.Wasm.Imports.WasmArg a8, IC.Wasm.Imports.WasmArg a9, IC.Wasm.Imports.WasmArg a10) => IC.Wasm.Imports.WasmArgs (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10)
instance (IC.Wasm.Imports.WasmArg a1, IC.Wasm.Imports.WasmArg a2, IC.Wasm.Imports.WasmArg a3, IC.Wasm.Imports.WasmArg a4, IC.Wasm.Imports.WasmArg a5, IC.Wasm.Imports.WasmArg a6, IC.Wasm.Imports.WasmArg a7, IC.Wasm.Imports.WasmArg a8, IC.Wasm.Imports.WasmArg a9, IC.Wasm.Imports.WasmArg a10, IC.Wasm.Imports.WasmArg a11, IC.Wasm.Imports.WasmArg a12) => IC.Wasm.Imports.WasmArgs (a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12)
instance IC.Wasm.Imports.WasmArg GHC.Int.Int32
instance IC.Wasm.Imports.WasmArg GHC.Word.Word64


-- | The canister interface, presented imperatively (or impurely), i.e.
--   without rollback
module IC.Canister.Imp
type CanisterEntryPoint r = forall s. (ImpState s -> ST s r)
data ImpState s
ImpState :: ESRef s -> Instance s -> Memory s -> Module -> ImpState s
[isESRef] :: ImpState s -> ESRef s
[isInstance] :: ImpState s -> Instance s
[isStableMem] :: ImpState s -> Memory s
[isModule] :: ImpState s -> Module
rawHeartbeat :: Env -> ImpState s -> ST s (TrapOr ([MethodCall], CanisterActions))
rawGlobalTimer :: Env -> ImpState s -> ST s (TrapOr ([MethodCall], CanisterActions))
rawInstantiate :: Module -> ST s (TrapOr (ImpState s))
rawInitialize :: EntityId -> Env -> Blob -> ImpState s -> ST s (TrapOr CanisterActions)
rawQuery :: MethodName -> EntityId -> Env -> Blob -> ImpState s -> ST s (TrapOr Response)
rawUpdate :: MethodName -> EntityId -> Env -> NeedsToRespond -> Cycles -> Blob -> ImpState s -> ST s (TrapOr UpdateResult)
rawCallback :: Callback -> Env -> NeedsToRespond -> Cycles -> Response -> Cycles -> ImpState s -> ST s (TrapOr UpdateResult)
rawCleanup :: WasmClosure -> Env -> ImpState s -> ST s (TrapOr ())
rawPreUpgrade :: EntityId -> Env -> ImpState s -> ST s (TrapOr (CanisterActions, Blob))
rawPostUpgrade :: EntityId -> Env -> Blob -> Blob -> ImpState s -> ST s (TrapOr CanisterActions)
rawInspectMessage :: MethodName -> EntityId -> Env -> Blob -> ImpState s -> ST s (TrapOr Bool)
instance GHC.Classes.Eq IC.Canister.Imp.ExecutionContext
instance GHC.Show.Show IC.Canister.Imp.ExecutionContext


-- | This module provides a way to persist the state of a Winter Wasm
--   instance, and to recover it.
--   
--   It is tailored to the use by ic-ref. For example it assumes that the
--   table of a wasm instance is immutable.
module IC.Wasm.Winter.Persist

-- | This stores data read from an instance.
newtype PInstance
PInstance :: Persisted (Instance ()) -> PInstance
data PModuleInst
PModuleInst :: Vector (Persisted (MemoryInst (ST ()))) -> Vector (Persisted (GlobalInst (ST ()))) -> PModuleInst
[memories] :: PModuleInst -> Vector (Persisted (MemoryInst (ST ())))
[globals] :: PModuleInst -> Vector (Persisted (GlobalInst (ST ())))
persistInstance :: Instance s -> ST s PInstance
resumeInstance :: Instance s -> PInstance -> ST s ()
persistMemory :: MemoryInst (ST s) -> ST s ByteString
resumeMemory :: MemoryInst (ST s) -> ByteString -> ST s ()
instance GHC.Show.Show IC.Wasm.Winter.Persist.PInstance
instance GHC.Show.Show IC.Wasm.Winter.Persist.PModuleInst
instance IC.Wasm.Winter.Persist.Persistable (Wasm.Runtime.Instance.ModuleInst Wasm.Util.Source.Phrase (GHC.ST.ST s))
instance IC.Wasm.Winter.Persist.Persistable (IC.Canister.StableMemory.Memory s)
instance IC.Wasm.Winter.Persist.Persistable (Wasm.Runtime.Memory.MemoryInst (GHC.ST.ST s))
instance IC.Wasm.Winter.Persist.Persistable (Wasm.Runtime.Global.GlobalInst (GHC.ST.ST s))
instance IC.Wasm.Winter.Persist.Persistable a => IC.Wasm.Winter.Persist.Persistable [a]
instance IC.Wasm.Winter.Persist.Persistable a => IC.Wasm.Winter.Persist.Persistable (Data.Vector.Vector a)
instance (GHC.Classes.Eq k, IC.Wasm.Winter.Persist.Persistable a) => IC.Wasm.Winter.Persist.Persistable (Data.Map.Internal.Map k a)
instance IC.Wasm.Winter.Persist.Persistable a => IC.Wasm.Winter.Persist.Persistable (Data.IntMap.Internal.IntMap a)
instance IC.Wasm.Winter.Persist.Persistable a => IC.Wasm.Winter.Persist.Persistable (a, GHC.Types.Int)

module IC.Canister.Snapshot
data CanisterSnapshot
CanisterSnapshot :: Module -> PInstance -> Repr -> CanisterSnapshot
[wsModule] :: CanisterSnapshot -> Module
[wsInstances] :: CanisterSnapshot -> PInstance
[wsStableMem] :: CanisterSnapshot -> Repr
instance GHC.Show.Show IC.Canister.Snapshot.CanisterSnapshot
instance IC.Purify.Purify IC.Canister.Imp.ImpState IC.Canister.Snapshot.CanisterSnapshot
instance IC.Purify.SnapshotAble IC.Canister.Imp.ImpState

module IC.Canister
type WasmState = CanisterSnapshot
parseCanister :: Blob -> Either String CanisterModule
decodeModule :: Blob -> Either String Blob
data CanisterModule
CanisterModule :: Blob -> Blob -> Bool -> Bool -> InitFunc -> (MethodName ↦ (EntityId -> Env -> NeedsToRespond -> Cycles -> Blob -> UpdateFunc)) -> (MethodName ↦ (EntityId -> Env -> Blob -> QueryFunc)) -> (Callback -> Env -> NeedsToRespond -> Cycles -> Response -> Cycles -> UpdateFunc) -> (WasmClosure -> Env -> WasmState -> TrapOr (WasmState, ())) -> (WasmState -> EntityId -> Env -> TrapOr (CanisterActions, Blob)) -> (EntityId -> Env -> Blob -> Blob -> TrapOr (WasmState, CanisterActions)) -> (MethodName -> EntityId -> Env -> Blob -> WasmState -> TrapOr Bool) -> (Env -> WasmState -> TrapOr (WasmState, ([MethodCall], CanisterActions))) -> (Env -> WasmState -> TrapOr (WasmState, ([MethodCall], CanisterActions))) -> (Text ↦ (IsPublic, Blob)) -> CanisterModule
[raw_wasm] :: CanisterModule -> Blob
[raw_wasm_hash] :: CanisterModule -> Blob
[exports_heartbeat] :: CanisterModule -> Bool
[exports_global_timer] :: CanisterModule -> Bool
[init_method] :: CanisterModule -> InitFunc
[update_methods] :: CanisterModule -> MethodName ↦ (EntityId -> Env -> NeedsToRespond -> Cycles -> Blob -> UpdateFunc)
[query_methods] :: CanisterModule -> MethodName ↦ (EntityId -> Env -> Blob -> QueryFunc)
[callbacks] :: CanisterModule -> Callback -> Env -> NeedsToRespond -> Cycles -> Response -> Cycles -> UpdateFunc
[cleanup] :: CanisterModule -> WasmClosure -> Env -> WasmState -> TrapOr (WasmState, ())
[pre_upgrade_method] :: CanisterModule -> WasmState -> EntityId -> Env -> TrapOr (CanisterActions, Blob)
[post_upgrade_method] :: CanisterModule -> EntityId -> Env -> Blob -> Blob -> TrapOr (WasmState, CanisterActions)
[inspect_message] :: CanisterModule -> MethodName -> EntityId -> Env -> Blob -> WasmState -> TrapOr Bool
[heartbeat] :: CanisterModule -> Env -> WasmState -> TrapOr (WasmState, ([MethodCall], CanisterActions))
[canister_global_timer] :: CanisterModule -> Env -> WasmState -> TrapOr (WasmState, ([MethodCall], CanisterActions))
[metadata] :: CanisterModule -> Text ↦ (IsPublic, Blob)
type InitFunc = EntityId -> Env -> Blob -> TrapOr (WasmState, CanisterActions)
type UpdateFunc = WasmState -> TrapOr (WasmState, UpdateResult)
type QueryFunc = WasmState -> TrapOr Response

-- | Turns a query function into an update function
asUpdate :: (EntityId -> Env -> Blob -> QueryFunc) -> EntityId -> Env -> NeedsToRespond -> Cycles -> Blob -> UpdateFunc
instance GHC.Show.Show IC.Canister.CanisterModule


-- | This module implements the main abstract types of the Internet
--   Computer.
module IC.Ref.Types
data CallRequest
CallRequest :: CanisterId -> UserId -> MethodName -> Blob -> CallRequest
data QueryRequest
QueryRequest :: CanisterId -> UserId -> MethodName -> Blob -> QueryRequest
data ReadStateRequest
ReadStateRequest :: UserId -> [Path] -> ReadStateRequest
data RequestStatus
Received :: RequestStatus
Processing :: RequestStatus
CallResponse :: CallResponse -> RequestStatus
data CallResponse
Rejected :: (RejectCode, String, Maybe ErrorCode) -> CallResponse
Replied :: Blob -> CallResponse
data ValidationError
HTTPError :: String -> ValidationError
ExecutionError :: (RejectCode, String, Maybe ErrorCode) -> ValidationError
data ReqResponse
RequestError :: (RejectCode, String, Maybe ErrorCode) -> ReqResponse
QueryResponse :: CallResponse -> ReqResponse
ReadStateResponse :: Certificate -> ReqResponse
data RunStatus
IsRunning :: RunStatus
IsStopping :: [CallId] -> RunStatus
IsStopped :: RunStatus
IsDeleted :: RunStatus
data CanisterContent
CanisterContent :: CanisterModule -> WasmState -> CanisterContent
[can_mod] :: CanisterContent -> CanisterModule
[wasm_state] :: CanisterContent -> WasmState
data CanisterHistory
CanisterHistory :: [Change] -> Word64 -> CanisterHistory
[changes] :: CanisterHistory -> [Change]
[total_num_changes] :: CanisterHistory -> Word64
data CanState
CanState :: Maybe CanisterContent -> RunStatus -> Set EntityId -> Natural -> Natural -> Natural -> Timestamp -> Natural -> Blob -> Natural -> CanisterHistory -> Natural -> Maybe EntryPoint -> CanState
[content] :: CanState -> Maybe CanisterContent
[run_status] :: CanState -> RunStatus
[controllers] :: CanState -> Set EntityId
[memory_allocation] :: CanState -> Natural
[compute_allocation] :: CanState -> Natural
[freezing_threshold] :: CanState -> Natural
[time] :: CanState -> Timestamp
[cycle_balance] :: CanState -> Natural
[certified_data] :: CanState -> Blob
[canister_version] :: CanState -> Natural
[canister_history] :: CanState -> CanisterHistory
[global_timer] :: CanState -> Natural

-- | Not part of the spec, but in this implementation we schedule
--   heartbeats only for canisters who have not been idle since the last
--   heartbeat, so we remember the last action.
[last_action] :: CanState -> Maybe EntryPoint
data EntryPoint
Public :: MethodName -> Blob -> EntryPoint
Closure :: Callback -> Response -> Cycles -> EntryPoint
Heartbeat :: EntryPoint
GlobalTimer :: EntryPoint
type CallId = Int
data CallContext
CallContext :: CanisterId -> CallOrigin -> NeedsToRespond -> Bool -> Cycles -> Maybe String -> CallContext
[canister] :: CallContext -> CanisterId
[origin] :: CallContext -> CallOrigin
[needs_to_respond] :: CallContext -> NeedsToRespond
[deleted] :: CallContext -> Bool
[available_cycles] :: CallContext -> Cycles

-- | non-normative, but yields better reject messages
[last_trap] :: CallContext -> Maybe String
data CallOrigin
FromUser :: RequestID -> CanisterId -> CallOrigin
FromCanister :: CallId -> Callback -> CallOrigin
FromSystemTask :: CallOrigin
data Message
CallMessage :: CallId -> EntryPoint -> Message
[call_context] :: Message -> CallId
[entry] :: Message -> EntryPoint
ResponseMessage :: CallId -> Response -> Cycles -> Message
[call_context] :: Message -> CallId
[response] :: Message -> Response
[refunded_cycles] :: Message -> Cycles
type Subnet = (EntityId, SubnetType, Word64, SecretKey, [(Word64, Word64)])
isRootSubnet :: Subnet -> Bool
data IC
IC :: (CanisterId ↦ CanState) -> (RequestID ↦ (CallRequest, (RequestStatus, CanisterId))) -> Seq Message -> (CallId ↦ CallContext) -> StdGen -> SecretKey -> Maybe EntityId -> [Subnet] -> IC
[canisters] :: IC -> CanisterId ↦ CanState
[requests] :: IC -> RequestID ↦ (CallRequest, (RequestStatus, CanisterId))
[messages] :: IC -> Seq Message
[call_contexts] :: IC -> CallId ↦ CallContext
[rng] :: IC -> StdGen
[secretRootKey] :: IC -> SecretKey
[rootSubnet] :: IC -> Maybe EntityId
[subnets] :: IC -> [Subnet]
type ICM m = (MonadState IC m, HasRefConfig, HasCallStack, MonadIO m)
initialIC :: [SubnetConfig] -> IO IC
type CanReject = MonadError (RejectCode, String, Maybe ErrorCode)
reject :: CanReject m => RejectCode -> String -> Maybe ErrorCode -> m a2
canisterRejected :: (RejectCode, String, Maybe ErrorCode) -> CallResponse
rejectMessage :: (RejectCode, String, Maybe ErrorCode) -> String
onReject :: ICM m => ((RejectCode, String, Maybe ErrorCode) -> m b) -> (forall m'. (CanReject m', ICM m') => m' b) -> m b
onErr :: Monad m => m (Either a b) -> (a -> m b) -> m b
orElse :: Monad m => m (Maybe a) -> m a -> m a
onTrap :: Monad m => m (TrapOr a) -> (String -> m a) -> m a
getSubnetFromCanisterId' :: ICM m => CanisterId -> m (Maybe Subnet)
getSubnetFromCanisterId :: (CanReject m, ICM m) => CanisterId -> m Subnet
getSubnetFromSubnetId :: (CanReject m, ICM m) => CanisterId -> m (Maybe Subnet)
getCanisterRootKey :: CanisterId -> ExtendedSecretKey
canisterMustExist :: (CanReject m, ICM m) => CanisterId -> m ()
isCanisterEmpty :: ICM m => CanisterId -> m Bool
createEmptyCanister :: ICM m => CanisterId -> Set EntityId -> Timestamp -> m ()
enqueueMessage :: ICM m => Message -> m ()
managementCanisterId :: EntityId
callerOfCallRequest :: CallRequest -> EntityId
callerOfRequest :: ICM m => RequestID -> m EntityId
callerOfCallID :: ICM m => CallId -> m EntityId
calleeOfCallID :: ICM m => CallId -> m EntityId
ecidOfCallID :: ICM m => CallId -> m CanisterId
getCallContext :: ICM m => CallId -> m CallContext
modifyCallContext :: ICM m => CallId -> (CallContext -> CallContext) -> m ()
getCallContextCycles :: ICM m => CallId -> m Cycles
setCallContextCycles :: ICM m => CallId -> Cycles -> m ()
respondCallContext :: ICM m => CallId -> Response -> m ()
replyCallContext :: ICM m => CallId -> Blob -> m ()
rejectCallContext :: ICM m => CallId -> (RejectCode, String, Maybe ErrorCode) -> m ()
deleteCallContext :: ICM m => CallId -> m ()
getCanister :: ICM m => CanisterId -> m CanState
modCanister :: ICM m => CanisterId -> (CanState -> CanState) -> m ()
setCanisterContent :: ICM m => CanisterId -> CanisterContent -> m ()
modCanisterContent :: ICM m => CanisterId -> (CanisterContent -> CanisterContent) -> m ()
setCanisterState :: ICM m => CanisterId -> WasmState -> m ()
getControllers :: ICM m => CanisterId -> m (Set EntityId)
setControllers :: ICM m => CanisterId -> Set EntityId -> m ()
setComputeAllocation :: ICM m => CanisterId -> Natural -> m ()
setMemoryAllocation :: ICM m => CanisterId -> Natural -> m ()
setFreezingThreshold :: ICM m => CanisterId -> Natural -> m ()
getBalance :: ICM m => CanisterId -> m Natural
setBalance :: ICM m => CanisterId -> Natural -> m ()
setCertifiedData :: ICM m => CanisterId -> Blob -> m ()
getRunStatus :: ICM m => CanisterId -> m RunStatus
setRunStatus :: ICM m => CanisterId -> RunStatus -> m ()
getCanisterState :: ICM m => CanisterId -> m WasmState
getCanisterMod :: ICM m => CanisterId -> m CanisterModule
getCanisterTime :: ICM m => CanisterId -> m Timestamp
getCanisterVersion :: ICM m => CanisterId -> m Natural
bumpCanisterVersion :: ICM m => CanisterId -> m ()
getCanisterHistory :: ICM m => CanisterId -> m CanisterHistory
addCanisterHistory :: ICM m => CanisterId -> Change -> m ()
getCanisterGlobalTimer :: ICM m => CanisterId -> m Natural
setCanisterGlobalTimer :: ICM m => CanisterId -> Natural -> m ()
module_hash :: CanState -> Maybe Blob
idle_cycles_burned_per_day :: CanState -> Natural
canisterEnv :: ICM m => CanisterId -> m Env
performCanisterActions :: ICM m => CanisterId -> CanisterActions -> m ()
instance GHC.Show.Show IC.Ref.Types.CallRequest
instance GHC.Classes.Ord IC.Ref.Types.CallRequest
instance GHC.Classes.Eq IC.Ref.Types.CallRequest
instance GHC.Show.Show IC.Ref.Types.CallResponse
instance GHC.Show.Show IC.Ref.Types.RequestStatus
instance GHC.Show.Show IC.Ref.Types.ReqResponse
instance GHC.Show.Show IC.Ref.Types.CanisterContent
instance GHC.Show.Show IC.Ref.Types.CanisterHistory
instance GHC.Show.Show IC.Ref.Types.EntryPoint
instance GHC.Show.Show IC.Ref.Types.RunStatus
instance GHC.Classes.Eq IC.Ref.Types.RunStatus
instance GHC.Show.Show IC.Ref.Types.CanState
instance GHC.Show.Show IC.Ref.Types.CallOrigin
instance GHC.Classes.Eq IC.Ref.Types.CallOrigin
instance GHC.Show.Show IC.Ref.Types.CallContext
instance GHC.Show.Show IC.Ref.Types.Message
instance GHC.Show.Show IC.Ref.Types.IC


-- | This module defines Serialise instances of the IC state.
--   
--   We put them into their own module, despite the usual advise against
--   orphan instances, to emphasize that these are not part of the
--   <a>Ref</a> module with its “reference implementation” status.
--   
--   Also, orphan instances are kinda ok in applications.
module IC.Serialise
instance GHC.Generics.Generic IC.Types.Timestamp
instance GHC.Generics.Generic IC.Types.NeedsToRespond
instance GHC.Generics.Generic IC.Types.RejectCode
instance GHC.Generics.Generic IC.Types.ErrorCode
instance GHC.Generics.Generic IC.Types.Response
instance GHC.Generics.Generic IC.Types.SubnetType
instance GHC.Generics.Generic IC.Types.WasmClosure
instance GHC.Generics.Generic IC.Types.Callback
instance GHC.Generics.Generic IC.Types.MethodCall
instance GHC.Generics.Generic IC.Wasm.Winter.Persist.PInstance
instance GHC.Generics.Generic IC.Wasm.Winter.Persist.PModuleInst
instance GHC.Generics.Generic (IC.Purify.Snapshot a)
instance GHC.Generics.Generic IC.Ref.Types.IC
instance GHC.Generics.Generic IC.Ref.Types.CallContext
instance GHC.Generics.Generic IC.Ref.Types.Message
instance GHC.Generics.Generic IC.Ref.Types.RequestStatus
instance GHC.Generics.Generic IC.Ref.Types.CallResponse
instance GHC.Generics.Generic IC.Ref.Types.CallRequest
instance GHC.Generics.Generic IC.Ref.Types.RunStatus
instance GHC.Generics.Generic IC.Types.CanisterInstallMode
instance GHC.Generics.Generic IC.Types.ChangeOrigin
instance GHC.Generics.Generic IC.Types.ChangeDetails
instance GHC.Generics.Generic IC.Types.Change
instance GHC.Generics.Generic IC.Ref.Types.CanisterHistory
instance GHC.Generics.Generic IC.Ref.Types.CanState
instance GHC.Generics.Generic IC.Ref.Types.CallOrigin
instance GHC.Generics.Generic IC.Ref.Types.EntryPoint
instance Codec.Serialise.Class.Serialise IC.Types.EntityId
instance Codec.Serialise.Class.Serialise System.Random.Internal.StdGen
instance Codec.Serialise.Class.Serialise Wasm.Syntax.Values.Value
instance Codec.Serialise.Class.Serialise IC.Types.Timestamp
instance Codec.Serialise.Class.Serialise IC.Types.NeedsToRespond
instance Codec.Serialise.Class.Serialise IC.Types.RejectCode
instance Codec.Serialise.Class.Serialise IC.Types.ErrorCode
instance Codec.Serialise.Class.Serialise IC.Types.Response
instance Codec.Serialise.Class.Serialise IC.Types.SubnetType
instance Codec.Serialise.Class.Serialise IC.Types.WasmClosure
instance Codec.Serialise.Class.Serialise IC.Types.Callback
instance Codec.Serialise.Class.Serialise IC.Types.MethodCall
instance Codec.Serialise.Class.Serialise IC.Wasm.Winter.Persist.PInstance
instance Codec.Serialise.Class.Serialise IC.Wasm.Winter.Persist.PModuleInst
instance Codec.Serialise.Class.Serialise a => Codec.Serialise.Class.Serialise (IC.Purify.Snapshot a)
instance Codec.Serialise.Class.Serialise IC.Ref.Types.IC
instance Codec.Serialise.Class.Serialise IC.Ref.Types.CallContext
instance Codec.Serialise.Class.Serialise IC.Ref.Types.Message
instance Codec.Serialise.Class.Serialise IC.Ref.Types.RequestStatus
instance Codec.Serialise.Class.Serialise IC.Ref.Types.CallResponse
instance Codec.Serialise.Class.Serialise IC.Ref.Types.CallRequest
instance Codec.Serialise.Class.Serialise IC.Ref.Types.RunStatus
instance Codec.Serialise.Class.Serialise IC.Types.CanisterInstallMode
instance Codec.Serialise.Class.Serialise IC.Types.ChangeOrigin
instance Codec.Serialise.Class.Serialise IC.Types.ChangeDetails
instance Codec.Serialise.Class.Serialise IC.Types.Change
instance Codec.Serialise.Class.Serialise IC.Ref.Types.CanisterHistory
instance Codec.Serialise.Class.Serialise IC.Ref.Types.CanState
instance Codec.Serialise.Class.Serialise IC.Ref.Types.CallOrigin
instance Codec.Serialise.Class.Serialise IC.Ref.Types.EntryPoint
instance Codec.Serialise.Class.Serialise IC.Ref.Types.CanisterContent
instance Codec.Serialise.Class.Serialise IC.Canister.StableMemory.Repr
instance Codec.Serialise.Class.Serialise System.Random.SplitMix.SMGen
instance Codec.Serialise.Class.Serialise IC.Crypto.BLS.SecretKey
instance Codec.Serialise.Class.Serialise IC.Crypto.SecretKey


-- | This module implements the canister HTTP outcall logic of the Internet
--   Computer.
module IC.Ref.HTTP
icHttpRequest :: (ICM m, CanReject m) => EntityId -> Maybe Subnet -> CallId -> ICManagement m .! "http_request"


-- | This module implements the management canister logic of the Internet
--   Computer.
module IC.Ref.Management
invokeManagementCanister :: forall m. (CanReject m, ICM m, MonadIO m) => EntityId -> Maybe Subnet -> CallId -> EntryPoint -> m ()


-- | This module implements the main abstract logic of the Internet
--   Computer. It assumes a pure and abstracted view on Canisters (provided
--   by <a>IC.Canister</a>), and deals with abstract requests
--   (<a>CallRequest</a>, <a>QueryRequest</a>, ...), so HTTP and CBOR-level
--   processing has already happened.
module IC.Ref
data IC
IC :: (CanisterId ↦ CanState) -> (RequestID ↦ (CallRequest, (RequestStatus, CanisterId))) -> Seq Message -> (CallId ↦ CallContext) -> StdGen -> SecretKey -> Maybe EntityId -> [Subnet] -> IC
[canisters] :: IC -> CanisterId ↦ CanState
[requests] :: IC -> RequestID ↦ (CallRequest, (RequestStatus, CanisterId))
[messages] :: IC -> Seq Message
[call_contexts] :: IC -> CallId ↦ CallContext
[rng] :: IC -> StdGen
[secretRootKey] :: IC -> SecretKey
[rootSubnet] :: IC -> Maybe EntityId
[subnets] :: IC -> [Subnet]
data CallRequest
CallRequest :: CanisterId -> UserId -> MethodName -> Blob -> CallRequest
callerOfCallRequest :: CallRequest -> EntityId
data QueryRequest
QueryRequest :: CanisterId -> UserId -> MethodName -> Blob -> QueryRequest
data ReadStateRequest
ReadStateRequest :: UserId -> [Path] -> ReadStateRequest
data RequestStatus
Received :: RequestStatus
Processing :: RequestStatus
CallResponse :: CallResponse -> RequestStatus
data ReqResponse
RequestError :: (RejectCode, String, Maybe ErrorCode) -> ReqResponse
QueryResponse :: CallResponse -> ReqResponse
ReadStateResponse :: Certificate -> ReqResponse
data CallResponse
Rejected :: (RejectCode, String, Maybe ErrorCode) -> CallResponse
Replied :: Blob -> CallResponse
initialIC :: [SubnetConfig] -> IO IC
authCallRequest :: RequestValidation m => Timestamp -> CanisterId -> EnvValidity -> CallRequest -> m ()
authQueryRequest :: RequestValidation m => Timestamp -> CanisterId -> EnvValidity -> QueryRequest -> m ()
authReadStateRequest :: RequestValidation m => Timestamp -> CanisterId -> EnvValidity -> ReadStateRequest -> m ()

-- | Submission simply enqueues requests
submitRequest :: ICM m => RequestID -> CallRequest -> CanisterId -> m ()
handleQuery :: ICM m => Timestamp -> QueryRequest -> m ReqResponse
handleReadState :: ICM m => Timestamp -> CanisterId -> ReadStateRequest -> m (Either Text ReqResponse)

-- | Returns true if a step was taken
runStep :: ICM m => m Bool
runToCompletion :: ICM m => m ()
processSystemTasks :: ICM m => m ()
setAllTimesTo :: ICM m => Timestamp -> m ()
createEmptyCanister :: ICM m => CanisterId -> Set EntityId -> Timestamp -> m ()
data CallContext
CallContext :: CanisterId -> CallOrigin -> NeedsToRespond -> Bool -> Cycles -> Maybe String -> CallContext
[canister] :: CallContext -> CanisterId
[origin] :: CallContext -> CallOrigin
[needs_to_respond] :: CallContext -> NeedsToRespond
[deleted] :: CallContext -> Bool
[available_cycles] :: CallContext -> Cycles

-- | non-normative, but yields better reject messages
[last_trap] :: CallContext -> Maybe String
data Message
CallMessage :: CallId -> EntryPoint -> Message
[call_context] :: Message -> CallId
[entry] :: Message -> EntryPoint
ResponseMessage :: CallId -> Response -> Cycles -> Message
[call_context] :: Message -> CallId
[response] :: Message -> Response
[refunded_cycles] :: Message -> Cycles
data CanState
CanState :: Maybe CanisterContent -> RunStatus -> Set EntityId -> Natural -> Natural -> Natural -> Timestamp -> Natural -> Blob -> Natural -> CanisterHistory -> Natural -> Maybe EntryPoint -> CanState
[content] :: CanState -> Maybe CanisterContent
[run_status] :: CanState -> RunStatus
[controllers] :: CanState -> Set EntityId
[memory_allocation] :: CanState -> Natural
[compute_allocation] :: CanState -> Natural
[freezing_threshold] :: CanState -> Natural
[time] :: CanState -> Timestamp
[cycle_balance] :: CanState -> Natural
[certified_data] :: CanState -> Blob
[canister_version] :: CanState -> Natural
[canister_history] :: CanState -> CanisterHistory
[global_timer] :: CanState -> Natural

-- | Not part of the spec, but in this implementation we schedule
--   heartbeats only for canisters who have not been idle since the last
--   heartbeat, so we remember the last action.
[last_action] :: CanState -> Maybe EntryPoint
data CallOrigin
FromUser :: RequestID -> CanisterId -> CallOrigin
FromCanister :: CallId -> Callback -> CallOrigin
FromSystemTask :: CallOrigin
data EntryPoint
Public :: MethodName -> Blob -> EntryPoint
Closure :: Callback -> Response -> Cycles -> EntryPoint
Heartbeat :: EntryPoint
GlobalTimer :: EntryPoint
data RunStatus
IsRunning :: RunStatus
IsStopping :: [CallId] -> RunStatus
IsStopped :: RunStatus
IsDeleted :: RunStatus
data CanisterContent
CanisterContent :: CanisterModule -> WasmState -> CanisterContent
[can_mod] :: CanisterContent -> CanisterModule
[wasm_state] :: CanisterContent -> WasmState


-- | Parses/produces generic requests
module IC.HTTP.Request
dummyUserId :: EntityId
stripEnvelope :: Blob -> GenR -> Either Text (GenR, EnvValidity)
type DelegationHash = Blob
delegationField :: Field (PublicKey, Timestamp, Maybe [EntityId], DelegationHash, Blob)
getTimestamp :: IO Timestamp
callRequest :: GenR -> Either Text CallRequest
queryRequest :: GenR -> Either Text QueryRequest
readStateRequest :: GenR -> Either Text ReadStateRequest
entitiyId :: Field EntityId
response :: ReqResponse -> GenR


-- | This module defines ToJSON instances of the IC state.
--   
--   We put them into their own module, despite the usual advise against
--   orphan instances, to emphasize that these are there just for debugging
--   purposes using `ic-ref`.
--   
--   (Why JSON? Because Browsers render them nicely in a interactive
--   display where you can open and collapse subcomponents – much easier to
--   get this feature this way, compared to writing custom HTML output.)
module IC.Debug.JSON
instance GHC.Generics.Generic IC.Types.Timestamp
instance GHC.Generics.Generic IC.Types.NeedsToRespond
instance GHC.Generics.Generic IC.Types.RejectCode
instance GHC.Generics.Generic IC.Types.ErrorCode
instance GHC.Generics.Generic IC.Types.Response
instance GHC.Generics.Generic IC.Types.SubnetType
instance GHC.Generics.Generic IC.Types.WasmClosure
instance GHC.Generics.Generic IC.Types.Callback
instance GHC.Generics.Generic IC.Types.MethodCall
instance GHC.Generics.Generic IC.Wasm.Winter.Persist.PInstance
instance GHC.Generics.Generic IC.Wasm.Winter.Persist.PModuleInst
instance GHC.Generics.Generic (IC.Purify.Snapshot a)
instance GHC.Generics.Generic IC.Canister.Snapshot.CanisterSnapshot
instance GHC.Generics.Generic IC.Ref.Types.IC
instance GHC.Generics.Generic IC.Ref.Types.CallContext
instance GHC.Generics.Generic IC.Ref.Types.Message
instance GHC.Generics.Generic IC.Ref.Types.RequestStatus
instance GHC.Generics.Generic IC.Ref.Types.CallResponse
instance GHC.Generics.Generic IC.Ref.Types.CallRequest
instance GHC.Generics.Generic IC.Ref.Types.RunStatus
instance GHC.Generics.Generic IC.Types.CanisterInstallMode
instance GHC.Generics.Generic IC.Types.ChangeOrigin
instance GHC.Generics.Generic IC.Types.ChangeDetails
instance GHC.Generics.Generic IC.Types.Change
instance GHC.Generics.Generic IC.Ref.Types.CanisterHistory
instance GHC.Generics.Generic IC.Ref.Types.CanState
instance GHC.Generics.Generic IC.Ref.Types.CanisterContent
instance GHC.Generics.Generic IC.Ref.Types.CallOrigin
instance GHC.Generics.Generic IC.Ref.Types.EntryPoint
instance Data.Aeson.Types.ToJSON.ToJSON Wasm.Syntax.Values.Value
instance Data.Aeson.Types.ToJSON.ToJSON Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Types.ToJSON.ToJSONKey Data.ByteString.Lazy.Internal.ByteString
instance Data.Aeson.Types.ToJSON.ToJSON (Wasm.Syntax.AST.Module f)
instance Data.Aeson.Types.ToJSON.ToJSON (IC.Purify.Replay i)
instance Data.Aeson.Types.ToJSON.ToJSON IC.Canister.StableMemory.Repr
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.Timestamp
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.NeedsToRespond
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.RejectCode
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.ErrorCode
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.Response
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.SubnetType
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.WasmClosure
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.Callback
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.MethodCall
instance Data.Aeson.Types.ToJSON.ToJSON IC.Wasm.Winter.Persist.PInstance
instance Data.Aeson.Types.ToJSON.ToJSON IC.Wasm.Winter.Persist.PModuleInst
instance Data.Aeson.Types.ToJSON.ToJSON a => Data.Aeson.Types.ToJSON.ToJSON (IC.Purify.Snapshot a)
instance Data.Aeson.Types.ToJSON.ToJSON IC.Canister.Snapshot.CanisterSnapshot
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.IC
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.CallContext
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.Message
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.RequestStatus
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.CallResponse
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.CallRequest
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.RunStatus
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.CanisterInstallMode
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.ChangeOrigin
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.ChangeDetails
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.Change
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.CanisterHistory
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.CanState
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.CanisterContent
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.CallOrigin
instance Data.Aeson.Types.ToJSON.ToJSON IC.Ref.Types.EntryPoint
instance Data.Aeson.Types.ToJSON.ToJSON IC.Canister.CanisterModule
instance Data.Aeson.Types.ToJSON.ToJSON IC.Types.EntityId
instance Data.Aeson.Types.ToJSON.ToJSONKey IC.Types.EntityId
instance Data.Aeson.Types.ToJSON.ToJSON System.Random.Internal.StdGen
instance Data.Aeson.Types.ToJSON.ToJSON IC.Crypto.SecretKey


-- | This module exports a source id in a way that works well within a nix
--   build (no .git available) and outside nix, according to this logic:
--   
--   <ul>
--   <li>If <tt>git</tt> works, use `git describe`</li>
--   <li>Else, if $out is set (so this is a nix build), extract an
--   identifer from the out hash</li>
--   <li>Else, it says something like unidentified build.</li>
--   </ul>
--   
--   This is an early experiment. If successful, this logic ought to move
--   into a library, and maybe also implemented for rust artifacts. (see
--   RPL-101)
--   
--   Note that cabal build will not recompile this module if it does not
--   have to, so in local development, this is less reliable than it
--   should. See
--   https:/<i>www.joachim-breitner.de</i>blog/772-Template_Haskell_recompilation
--   for more details.
module SourceId
id :: String

module IC.Version
specVersion :: Text
implVersion :: Text


-- | This module contains function to interact with an Internet Computer
--   instance.
--   
--   The primary customer here is IC.Test.Spec, i.e the test suite.
--   Therefore, the functions here give access to varoius levels of
--   abstractions, and gives more control than a “normal” agent library
--   would do.
--   
--   Also, because of the focus on testing, failures are repoted directly
--   with HUnit’s <a>assertFailure</a>.
--   
--   As guidance: This modules does _not_ rely on the universal canister.
module IC.Test.Agent
type HTTPErrOr a = Either (Int, String) a
type HasAgentConfig = (?agentConfig :: AgentConfig)
type IC00 = Blob -> Text -> Blob -> IO ReqResponse
type IC00WithCycles = Word64 -> IC00
type IC00' = Blob -> Text -> Blob -> IO (HTTPErrOr ReqResponse)
data ReqResponse
Reply :: Blob -> ReqResponse
Reject :: Natural -> Text -> Maybe Text -> ReqResponse
data ReqStatus
Processing :: ReqStatus
Pending :: ReqStatus
Responded :: ReqResponse -> ReqStatus
UnknownStatus :: ReqStatus
data AgentConfig
AgentConfig :: Blob -> Manager -> String -> [AgentSubnetConfig] -> String -> Int -> AgentConfig
[tc_root_key] :: AgentConfig -> Blob
[tc_manager] :: AgentConfig -> Manager
[tc_endPoint] :: AgentConfig -> String
[tc_subnets] :: AgentConfig -> [AgentSubnetConfig]
[tc_httpbin] :: AgentConfig -> String
[tc_timeout] :: AgentConfig -> Int
data DelegationCanisterRangeCheck
DelegationCanisterRangeCheck :: [(Blob, Blob)] -> Blob -> DelegationCanisterRangeCheck
addExpiry :: GenR -> IO GenR
addNonce :: GenR -> IO GenR
addNonceExpiryEnv :: GenR -> IO GenR
anonymousUser :: Blob
as2Word64 :: HasCallStack => Blob -> IO (Word64, Word64)
asWord64Word128 :: HasCallStack => Blob -> IO (Word64, Word128)
asHex :: Blob -> String
asRight :: HasCallStack => Either Text a -> IO a
asWord128 :: HasCallStack => Blob -> IO Word128
asWord32 :: HasCallStack => Blob -> IO Word32
asWord64 :: HasCallStack => Blob -> IO Word64

-- | Add envelope to CBOR, and a nonce and expiry if not there, post to
--   "submit". Returns either a HTTP Error code, or if the status is 2xx,
--   poll for the request response, and return decoded CBOR
awaitCall' :: (HasCallStack, HasAgentConfig) => Blob -> GenR -> IO (HTTPErrOr ReqResponse)

-- | Add envelope to CBOR, and a nonce and expiry if not there, post to
--   "submit", poll for the request response, and return decoded CBOR
awaitCall :: (HasCallStack, HasAgentConfig) => Blob -> GenR -> IO ReqResponse
awaitKnown :: HasAgentConfig => IO (HTTPErrOr ReqStatus) -> IO ReqStatus
awaitStatus :: HasAgentConfig => IO (HTTPErrOr ReqStatus) -> IO ReqResponse
bothSame :: (Eq a, Show a) => (a, a) -> Assertion
callResponse :: GenR -> IO ReqResponse
certValue :: HasCallStack => CertVal a => Certificate -> [Blob] -> IO a
certValueAbsent :: HasCallStack => Certificate -> [Blob] -> IO ()
code202 :: HasCallStack => Response ByteString -> IO ()
code202_or_4xx :: HasCallStack => Response ByteString -> IO ()
code2xx :: HasCallStack => Response ByteString -> IO ()
code4xx :: HasCallStack => Response ByteString -> IO ()
decodeCert' :: HasCallStack => Blob -> IO Certificate
defaultSK :: SecretKey
defaultUser :: Blob
delegationEnv :: SecretKey -> [(SecretKey, Maybe [Blob])] -> GenR -> IO GenR
doesn'tExist :: Blob
ecdsaSK :: SecretKey
ecdsaUser :: Blob
enum :: (AllUniqueLabels r, KnownSymbol l, (r .! l) ~ ()) => Label l -> Var r
envelope :: SecretKey -> GenR -> IO GenR
envelopeFor :: Blob -> GenR -> IO GenR
extractCertData :: Blob -> Blob -> IO Blob
getRequestStatus' :: (HasCallStack, HasAgentConfig) => Blob -> Blob -> Blob -> IO (HTTPErrOr ReqStatus)
getRequestStatus :: (HasCallStack, HasAgentConfig) => Blob -> Blob -> Blob -> IO ReqStatus
getStateCert' :: (HasCallStack, HasAgentConfig) => Blob -> Blob -> [[Blob]] -> IO (HTTPErrOr Certificate)
getStateCert :: (HasCallStack, HasAgentConfig) => Blob -> Blob -> [[Blob]] -> IO Certificate
ic00 :: HasAgentConfig => IC00
ic00as :: (HasAgentConfig, HasCallStack) => Blob -> IC00
ic00' :: HasAgentConfig => IC00'
ic00WithSubnetas' :: HasAgentConfig => Blob -> Blob -> Blob -> Text -> Blob -> IO (HTTPErrOr ReqResponse)
ingressDelay :: IO ()
is2xx :: HasCallStack => HTTPErrOr a -> IO a
isErr4xx :: HasCallStack => HTTPErrOr a -> IO ()
isErrOrReject :: HasCallStack => [Natural] -> HTTPErrOr ReqResponse -> IO ()
isNoErrReject :: HasCallStack => [Natural] -> HTTPErrOr ReqResponse -> IO ()
isPendingOrProcessing :: ReqStatus -> IO ()
isReject :: HasCallStack => [Natural] -> ReqResponse -> IO ()
isReply :: HasCallStack => ReqResponse -> IO Blob
isResponded :: ReqStatus -> Assertion
okCBOR :: HasCallStack => Response ByteString -> IO GenR
otherSK :: SecretKey
otherUser :: Blob
makeAgentConfig :: Bool -> String -> [AgentSubnetConfig] -> String -> Int -> IO AgentConfig

-- | postCBOR with url based on effective canister id
postCBOR :: (HasCallStack, HasAgentConfig) => String -> GenR -> IO (Response ByteString)
postCallCBOR :: (HasCallStack, HasAgentConfig) => Blob -> GenR -> IO (Response ByteString)
postQueryCBOR :: (HasCallStack, HasAgentConfig) => Blob -> GenR -> IO (Response ByteString)
postReadStateCBOR :: (HasCallStack, HasAgentConfig) => Blob -> GenR -> IO (Response ByteString)
preFlight :: OptionSet -> IO AgentConfig

-- | Add envelope to CBOR request, add a nonce and expiry if it is not
--   there, post to "read", return decoded CBOR
queryCBOR :: (HasCallStack, HasAgentConfig) => Blob -> GenR -> IO GenR
queryResponse :: GenR -> IO ReqResponse
runGet :: HasCallStack => Get a -> Blob -> IO a
secp256k1SK :: SecretKey
secp256k1User :: Blob
senderOf :: GenR -> Blob
shorten :: Int -> String -> String
submitCall :: (HasCallStack, HasAgentConfig) => Blob -> GenR -> IO (IO (HTTPErrOr ReqStatus))
textual :: Blob -> String
validateStateCert :: (HasCallStack, HasAgentConfig) => Blob -> Certificate -> IO ()
verifySignature :: Blob -> Blob -> Blob -> Bool
waitFor :: HasAgentConfig => IO (Maybe a) -> IO a
webAuthnECDSASK :: SecretKey
webAuthnECDSAUser :: Blob
webAuthnRSASK :: SecretKey
webAuthnRSAUser :: Blob
withAgentConfig :: (HasAgentConfig => a) -> AgentConfig -> a
callIC :: forall s a b. (HasCallStack, HasAgentConfig) => KnownSymbol s => (a -> IO b) ~ (ICManagement IO .! s) => (CandidArg a, CandidArg b) => IC00 -> Blob -> Label s -> a -> IO b
callIC' :: forall s a b. HasAgentConfig => KnownSymbol s => (a -> IO b) ~ (ICManagement IO .! s) => CandidArg a => IC00 -> Blob -> Label s -> a -> IO ReqResponse
callIC'' :: forall s a b. HasAgentConfig => KnownSymbol s => (a -> IO b) ~ (ICManagement IO .! s) => CandidArg a => Blob -> Blob -> Label s -> a -> IO (HTTPErrOr ReqResponse)
callICWithSubnet'' :: forall s a b. HasAgentConfig => KnownSymbol s => (a -> IO b) ~ (ICManagement IO .! s) => CandidArg a => Blob -> Blob -> Blob -> Label s -> a -> IO (HTTPErrOr ReqResponse)
callIC''' :: forall s a b. HasAgentConfig => KnownSymbol s => (a -> IO b) ~ (ICManagement IO .! s) => CandidArg a => IC00' -> Blob -> Label s -> a -> IO (HTTPErrOr ReqResponse)
agentConfig :: HasAgentConfig => AgentConfig
instance GHC.Exception.Type.Exception IC.Test.Agent.DelegationCanisterRangeCheck
instance GHC.Show.Show IC.Test.Agent.DelegationCanisterRangeCheck
instance GHC.Show.Show IC.Test.Agent.ReqResponse
instance GHC.Classes.Eq IC.Test.Agent.ReqResponse
instance GHC.Show.Show IC.Test.Agent.ReqStatus
instance GHC.Classes.Eq IC.Test.Agent.ReqStatus

module IC.Test.Agent.Calls
httpbin :: HasAgentConfig => String
toTransformFn :: Maybe (String, a) -> Blob -> Maybe (Rec ('R '["context" :-> a, "function" :-> FuncRef r]))
type family UnRec r
type PartialSettings r = (Forall r Unconstrained1, Map Maybe r .// UnRec Settings ≈ UnRec Settings)
fromPartialSettings :: PartialSettings r => Rec r -> Settings

module IC.Test.Agent.UserCalls
ic_canister_status'' :: HasAgentConfig => Blob -> Blob -> IO (HTTPErrOr ReqResponse)
ic_canister_info'' :: HasAgentConfig => Blob -> Blob -> Maybe Word64 -> IO (HTTPErrOr ReqResponse)
ic_delete_canister'' :: HasAgentConfig => Blob -> Blob -> IO (HTTPErrOr ReqResponse)
ic_deposit_cycles'' :: HasAgentConfig => Blob -> Blob -> IO (HTTPErrOr ReqResponse)
ic_ecdsa_public_key'' :: HasAgentConfig => Blob -> Blob -> IO (HTTPErrOr ReqResponse)
ic_http_get_request'' :: HasAgentConfig => Blob -> Blob -> IO (HTTPErrOr ReqResponse)
ic_install'' :: (HasCallStack, HasAgentConfig) => Blob -> InstallMode -> Blob -> Blob -> Blob -> IO (HTTPErrOr ReqResponse)
ic_raw_rand'' :: HasAgentConfig => Blob -> Blob -> IO (HTTPErrOr ReqResponse)
ic_set_controllers'' :: HasAgentConfig => Blob -> Blob -> [Blob] -> IO (HTTPErrOr ReqResponse)
ic_sign_with_ecdsa'' :: HasAgentConfig => Blob -> Blob -> Blob -> IO (HTTPErrOr ReqResponse)
ic_start_canister'' :: HasAgentConfig => Blob -> Blob -> IO (HTTPErrOr ReqResponse)
ic_stop_canister'' :: HasAgentConfig => Blob -> Blob -> IO (HTTPErrOr ReqResponse)
ic_top_up''' :: HasAgentConfig => IC00' -> Blob -> Natural -> IO (HTTPErrOr ReqResponse)
ic_uninstall'' :: HasAgentConfig => Blob -> Blob -> IO (HTTPErrOr ReqResponse)

module IC.Test.Agent.UnsafeCalls
ic_canister_status :: forall a b. (a -> IO b) ~ (ICManagement IO .! "canister_status") => HasAgentConfig => IC00 -> Blob -> IO b
ic_canister_info :: forall a b. (a -> IO b) ~ (ICManagement IO .! "canister_info") => HasAgentConfig => IC00 -> Blob -> Maybe Word64 -> IO b
ic_create :: (HasCallStack, HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Rec r -> IO Blob
ic_create_with_sender_canister_version :: (HasCallStack, HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Maybe Word64 -> Rec r -> IO Blob
ic_delete_canister :: HasAgentConfig => IC00 -> Blob -> IO ()
ic_deposit_cycles :: HasAgentConfig => IC00 -> Blob -> IO ()
ic_ecdsa_public_key :: forall a b. (a -> IO b) ~ (ICManagement IO .! "ecdsa_public_key") => HasAgentConfig => IC00 -> Blob -> Maybe Blob -> Vector Blob -> IO b
ic_http_get_request :: forall a b. (a -> IO b) ~ (ICManagement IO .! "http_request") => HasAgentConfig => IC00WithCycles -> TestSubnetConfig -> String -> Maybe Word64 -> Maybe (String, Blob) -> Blob -> IO b
ic_http_post_request :: HasAgentConfig => (a -> IO b) ~ (ICManagement IO .! "http_request") => IC00WithCycles -> TestSubnetConfig -> String -> Maybe Word64 -> Maybe ByteString -> Vector HttpHeader -> Maybe (String, Blob) -> Blob -> IO b
ic_http_head_request :: HasAgentConfig => (a -> IO b) ~ (ICManagement IO .! "http_request") => IC00WithCycles -> TestSubnetConfig -> String -> Maybe Word64 -> Maybe ByteString -> Vector HttpHeader -> Maybe (String, Blob) -> Blob -> IO b
ic_long_url_http_request :: HasAgentConfig => forall a b. (a -> IO b) ~ (ICManagement IO .! "http_request") => IC00WithCycles -> TestSubnetConfig -> String -> Word64 -> Maybe (String, Blob) -> Blob -> IO b
ic_install :: (HasCallStack, HasAgentConfig) => IC00 -> InstallMode -> Blob -> Blob -> Blob -> IO ()
ic_install_with_sender_canister_version :: (HasCallStack, HasAgentConfig) => IC00 -> InstallMode -> Blob -> Blob -> Blob -> Maybe Word64 -> IO ()
ic_provisional_create :: (HasCallStack, HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Maybe Principal -> Maybe Natural -> Rec r -> IO Blob
ic_provisional_create_with_sender_canister_version :: (HasCallStack, HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Maybe Principal -> Maybe Natural -> Maybe Word64 -> Rec r -> IO Blob
ic_raw_rand :: HasAgentConfig => IC00 -> Blob -> IO Blob
ic_set_controllers :: HasAgentConfig => IC00 -> Blob -> [Blob] -> IO ()
ic_set_controllers_with_sender_canister_version :: HasAgentConfig => IC00 -> Blob -> Maybe Word64 -> [Blob] -> IO ()
ic_sign_with_ecdsa :: forall a b. (a -> IO b) ~ (ICManagement IO .! "sign_with_ecdsa") => HasAgentConfig => IC00 -> Blob -> Blob -> IO b
ic_start_canister :: HasAgentConfig => IC00 -> Blob -> IO ()
ic_stop_canister :: HasAgentConfig => IC00 -> Blob -> IO ()
ic_top_up :: HasAgentConfig => IC00 -> Blob -> Natural -> IO ()
ic_uninstall :: (HasCallStack, HasAgentConfig) => IC00 -> Blob -> IO ()
ic_uninstall_with_sender_canister_version :: (HasCallStack, HasAgentConfig) => IC00 -> Blob -> Maybe Word64 -> IO ()
ic_update_settings :: (HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Rec r -> IO ()
ic_update_settings_with_sender_canister_version :: (HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Maybe Word64 -> Rec r -> IO ()

module IC.Test.Agent.SafeCalls
ic_create' :: (HasCallStack, HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Rec r -> IO ReqResponse
ic_create_with_sender_canister_version' :: (HasCallStack, HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Maybe Word64 -> Rec r -> IO ReqResponse
ic_delete_canister' :: HasAgentConfig => IC00 -> Blob -> IO ReqResponse
ic_deposit_cycles' :: HasAgentConfig => IC00 -> Blob -> IO ReqResponse
ic_ecdsa_public_key' :: HasAgentConfig => IC00 -> Blob -> Maybe Blob -> Vector Blob -> IO ReqResponse
ic_http_invalid_address_request' :: HasAgentConfig => IC00WithCycles -> TestSubnetConfig -> String -> Maybe Word64 -> Maybe (String, Blob) -> Blob -> IO ReqResponse
ic_http_get_request' :: HasAgentConfig => IC00WithCycles -> TestSubnetConfig -> String -> String -> Maybe Word64 -> Maybe (String, Blob) -> Blob -> IO ReqResponse
ic_http_post_request' :: HasAgentConfig => IC00WithCycles -> TestSubnetConfig -> String -> Maybe Word64 -> Maybe ByteString -> Vector HttpHeader -> Maybe (String, Blob) -> Blob -> IO ReqResponse
ic_http_head_request' :: HasAgentConfig => IC00WithCycles -> TestSubnetConfig -> String -> Maybe Word64 -> Maybe ByteString -> Vector HttpHeader -> Maybe (String, Blob) -> Blob -> IO ReqResponse
ic_long_url_http_request' :: HasAgentConfig => IC00WithCycles -> TestSubnetConfig -> String -> Word64 -> Maybe (String, Blob) -> Blob -> IO ReqResponse
ic_install' :: HasAgentConfig => IC00 -> InstallMode -> Blob -> Blob -> Blob -> IO ReqResponse
ic_install_with_sender_canister_version' :: HasAgentConfig => IC00 -> InstallMode -> Blob -> Blob -> Blob -> Maybe Word64 -> IO ReqResponse
ic_provisional_create' :: (HasCallStack, HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Maybe Principal -> Maybe Natural -> Rec r -> IO ReqResponse
ic_provisional_create_with_sender_canister_version' :: (HasCallStack, HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Maybe Principal -> Maybe Natural -> Maybe Word64 -> Rec r -> IO ReqResponse
ic_raw_rand' :: HasAgentConfig => IC00 -> Blob -> IO ReqResponse
ic_set_controllers' :: HasAgentConfig => IC00 -> Blob -> [Blob] -> IO ReqResponse
ic_set_controllers_with_sender_canister_version' :: HasAgentConfig => IC00 -> Blob -> Maybe Word64 -> [Blob] -> IO ReqResponse
ic_top_up' :: HasAgentConfig => IC00 -> Blob -> Natural -> IO ReqResponse
ic_update_settings' :: (HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Rec r -> IO ReqResponse
ic_update_settings_with_sender_canister_version' :: (HasAgentConfig, PartialSettings r) => IC00 -> Blob -> Maybe Word64 -> Rec r -> IO ReqResponse

module IC.Test.Spec.Utils
type Blob = ByteString
is :: (HasCallStack, Eq a, Show a) => a -> a -> Assertion
isSet :: (HasCallStack, Ord a, Show a) => [a] -> [a] -> Assertion
isContainedIn :: (HasCallStack, Ord a, Show a) => a -> [(a, a)] -> Assertion
trivialWasmModule :: Blob
queryToNonExistant :: GenR
readStateEmpty :: GenR
badEnvelope :: GenR -> GenR
noDomainSepEnv :: SecretKey -> GenR -> IO GenR
noExpiryEnv :: GenR -> GenR
pastExpiryEnv :: GenR -> GenR
futureExpiryEnv :: GenR -> GenR
deleteField :: Text -> GenR -> GenR
modNatField :: Text -> (Natural -> Natural) -> GenR -> GenR
awaitCallTwice :: HasAgentConfig => Blob -> GenR -> IO ReqResponse
asCBORBlobList :: Blob -> IO [Blob]
cborToBlob :: GenR -> IO Blob
ic00viaWithCyclesSubnetImpl' :: HasAgentConfig => Prog -> Prog -> Blob -> Blob -> IC00WithCycles
ic00viaWithCyclesSubnet' :: HasAgentConfig => Blob -> Blob -> IC00WithCycles
ic00via :: HasAgentConfig => Blob -> IC00
ic00viaWithCyclesSubnetImpl :: HasAgentConfig => Prog -> Prog -> Blob -> Blob -> IC00WithCycles
ic00viaWithCyclesSubnet :: HasAgentConfig => Blob -> Blob -> IC00WithCycles
ic00viaWithCycles :: HasAgentConfig => Blob -> IC00WithCycles
ic00viaWithCyclesRefundSubnet :: HasAgentConfig => Word64 -> Blob -> Blob -> IC00WithCycles
ic00viaWithCyclesRefund :: HasAgentConfig => Word64 -> Blob -> IC00WithCycles
install' :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ReqResponse
installAt :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ()
install :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO Blob
create :: (HasCallStack, HasAgentConfig) => Blob -> IO Blob
upgrade' :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ReqResponse
upgrade :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ()
reinstall' :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ReqResponse
reinstall :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ()
callRequestAs :: (HasCallStack, HasAgentConfig) => Blob -> Blob -> Prog -> GenR
callToQueryRequestAs :: (HasCallStack, HasAgentConfig) => Blob -> Blob -> Prog -> GenR
callRequest :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> GenR
callToQuery'' :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO (HTTPErrOr ReqResponse)
stopRequest :: (HasCallStack, HasAgentConfig) => Blob -> GenR
call'' :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO (HTTPErrOr ReqResponse)
call' :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ReqResponse
call :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO Blob
call_ :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ()
callTwice' :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ReqResponse
counterRef :: IORef Word32
incrementCount :: IO Word32
query' :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ReqResponse
query :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO Blob
query_ :: (HasCallStack, HasAgentConfig) => Blob -> Prog -> IO ()
isRelay :: HasCallStack => Blob -> IO ReqResponse
simpleTestCase :: (HasCallStack, HasAgentConfig) => String -> Blob -> (Blob -> IO ()) -> TestTree

-- | Runs test once for each field with that field removed, including
--   nested fields
omitFields :: GenR -> (GenR -> Assertion) -> [TestTree]
getTestFile :: FilePath -> IO FilePath
getTestWasm :: FilePath -> IO ByteString
barrier :: HasAgentConfig => [Blob] -> IO ()
createMessageHold :: HasAgentConfig => Blob -> IO (Prog, IO ())
vec_header_from_list_text :: [(Text, Text)] -> Vector HttpHeader
dummyResponse :: HttpResponse
bodyOfSize :: Word32 -> ByteString
maximumSizeResponseBodySize :: Word32


-- | This module contains a test suite for the Internet Computer
module IC.Test.Spec.Timer
canister_timer_tests :: HasAgentConfig => Blob -> [TestTree]

module IC.Test.Spec.TECDSA
tests :: HasAgentConfig => Blob -> TestTree


-- | This module contains a test suite for the Internet Computer
module IC.Test.Spec.HTTP
canister_http_calls :: HasAgentConfig => TestSubnetConfig -> [TestTree]
instance GHC.Classes.Eq IC.Test.Spec.HTTP.HttpRequestBody
instance Data.Aeson.Types.FromJSON.FromJSON IC.Test.Spec.HTTP.HttpRequest
instance Data.Aeson.Types.FromJSON.FromJSON IC.Test.Spec.HTTP.HttpRequestBody
instance Data.Aeson.Types.FromJSON.FromJSON IC.Test.Spec.HTTP.HttpRequestHeaders


-- | This module contains a test suite for the Internet Computer
module IC.Test.Spec.CanisterVersion
canister_version_tests :: HasAgentConfig => Blob -> [TestTree]


-- | This module contains a test suite for the Internet Computer
module IC.Test.Spec.CanisterHistory
canister_history_tests :: HasAgentConfig => Blob -> [TestTree]


-- | This module contains a test suite for the Internet Computer
module IC.Test.Spec
icTests :: TestSubnetConfig -> TestSubnetConfig -> AgentConfig -> TestTree


-- | the response to the status request
module IC.HTTP.Status
r :: IC -> GenR

module IC.HTTP
withApp :: HasRefConfig => [SubnetConfig] -> Int -> Maybe FilePath -> (Application -> IO a) -> IO a
handle :: HasRefConfig => Store IC -> Application
